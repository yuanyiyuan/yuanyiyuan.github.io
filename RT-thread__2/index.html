



<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="天元の" href="https://github.com/yuanyiyuan/yuanyiyuan.github.io.git/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="天元の" href="https://github.com/yuanyiyuan/yuanyiyuan.github.io.git/atom.xml" />
<link rel="alternate" type="application/json" title="天元の" href="https://github.com/yuanyiyuan/yuanyiyuan.github.io.git/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/css/app.css?v=0.2.5">

  
  <meta name="keywords" content="RT-thread" />


<link rel="canonical" href="https://github.com/yuanyiyuan/yuanyiyuan.github.io.git/RT-thread__2/">



  <title>
RT-thread__2 |
Tian yuan = 天元の = 宇宙中的每一粒尘埃都有着迷人的故事</title>
<meta name="generator" content="Hexo 5.4.0"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">RT-thread__2
  </h1>
  
<div class="meta">
  <span class="item" title="Created: 2021-07-23 13:47:47">
    <span class="icon">
      <i class="ic i-calendar"></i>
    </span>
    <span class="text">Posted on</span>
    <time itemprop="dateCreated datePublished" datetime="2021-07-23T13:47:47+08:00">2021-07-23</time>
  </span>
</div>


          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="Toggle navigation bar">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/" rel="start">Tian yuan</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
        <ul>
          <li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipesrnqv3j20zk0m8ava.jpg"></li>
          <li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipetfk5zwj20zk0m8e81.jpg"></li>
          <li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giclfw2t96j20zk0m8x6p.jpg"></li>
          <li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giciszlczyj20zk0m816d.jpg"></li>
          <li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giclize41wj20zk0m87gk.jpg"></li>
          <li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giph4baakhj20zk0m8h5q.jpg"></li>
        </ul>
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="article wrap">
    
<div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList">
<i class="ic i-home"></i>
<span><a href="/">Home</a></span>
</div>

    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="en">
  <link itemprop="mainEntityOfPage" href="https://github.com/yuanyiyuan/yuanyiyuan.github.io.git/RT-thread__2/">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/images/avatar.jpg">
    <meta itemprop="name" content="~元~">
    <meta itemprop="description" content="宇宙中的每一粒尘埃都有着迷人的故事, ">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="天元の">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <p><strong>移植 RT-Threaad 后的启程：</strong></p>
<h2 id="1-创建线程"><a href="#1-创建线程" class="headerlink" title="1.创建线程"></a>1.创建线程</h2><pre><code>/*\ 硬件初始化： 在移植过程中，首先先在board.c的rt_hw_board_init()函数中初始化  
    [在执行此函数的时候，操作系统还没有完全涉及到，此函数和裸机初始化一样，运行完此函数，才慢慢启动操作系统，最后创建线程] 
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">创建线程————SRAM静态内存</span><br><span class="line">    **线程使用的栈和线程控制块都使用静态内存，都是预先定义好的全局变量，都存在内部的SRAM中**</span><br><span class="line">    创建线程的三要素：</span><br><span class="line">            1.定义线程函数&lt;即主体&gt;</span><br><span class="line">                static void xxx_thread_entry (void *agr)</span><br><span class="line">                &#123;</span><br><span class="line">                    while(1)</span><br><span class="line">                    &#123;</span><br><span class="line">                      ......  //线程要执行的内容</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            2.定义线程栈&lt;因为预先要安排内存，所以先定义此线程要占用的内存&gt;</span><br><span class="line">                每个线程都是独立的，他们的运行环境都单独保存在他们的栈空间中，为一个独立的全局变量</span><br><span class="line">                ALIGN(RT_ALIGN_SIZE)                       //定义栈字节的对齐方式  【此为宏定义，只针对ARM编译器，其他的编译器，该宏的实现不一样】</span><br><span class="line">                static rt_uint8_t xxx_thread_stack[xx];    //定义线程栈</span><br><span class="line">            3.定义线程控制块</span><br><span class="line">                为一个结构体，里面有许多成员，描述了线程的全部信息[即为线程的身份证]</span><br><span class="line">                static struct rt_thread xxx_thread;</span><br><span class="line"></span><br><span class="line"> /**初始化线程：静态线程要把三要素联合起来，要用 rt_thread_init(); [将线程主体、线程栈(静态)、线程控制块(静态)联合起来，让线程随时被系统启动]</span><br><span class="line">                |--&gt; 线程控制块指针  </span><br><span class="line">                            |--&gt;在使用静态内存的时候，需要给线程初始化函数传递预先定义好的线程控制块的指针</span><br><span class="line">                            |--&gt;在使用动态内存的时候，线程的创建函数会返回一个指针指向线程控制块，该线程控制块是创建函数里面动态分配的一块内存</span><br><span class="line">                |--&gt;......其余的形参 【比较好理解】</span><br><span class="line">    启动线程：  线程初始化好后，是处于线程初始态(RT_THREAD_INIT),并不能参与操作系统的调度，只有线程进入就绪态(RT_THREAD_READY)之后才能参与操作系统的调度</span><br><span class="line">                线程由初始态进入就绪态可由函数rt_thread_startup(); 来实现</span><br><span class="line">                |--&gt;形参为  线程控制块指针</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">创建线程————SRAM动态内存</span><br><span class="line">    **线程使用的栈和线程控制块是在创建线程的时候RTOS动态分配的，开始使用 动态内存 [即为堆,也为SRAM]  ---&gt; 是先在SRAM里定义一个大数组供系统动态分配函数使用</span><br><span class="line">        |--&gt; #define RT_HEAP_SIZE  XXX   //从内部SRAM里面定义一个静态数组rt_heap,大小由此宏来决定</span><br><span class="line">            |--&gt; rt_heap_begin_get();    //用于获取堆的起始地址</span><br><span class="line">            |--&gt; rt_heap_end_get();      //用于获取堆的结束地址</span><br><span class="line">        |------&gt; rt_system_heap_init()   //根据堆的起始地址和结束地址进行初始化</span><br><span class="line">    创建线程的三要素：</span><br><span class="line">                    1.定义线程函数&lt;即主体&gt;</span><br><span class="line">                        static void xxx_thread_entry (void *agr)</span><br><span class="line">                        &#123;</span><br><span class="line">                            while(1)</span><br><span class="line">                            &#123;</span><br><span class="line">                            ......  //线程要执行的内容</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    2.定义线程栈</span><br><span class="line">                        使用动态内存的时候，线程栈在【线程创建】的时候创建</span><br><span class="line">                    3.定义线程控制块指针</span><br><span class="line">                        线程控制块是在线程创建的时候创建，线程创建函数会返回一个指针，用于指向线程控制块</span><br><span class="line">                        **所以要&lt;&lt;&lt;预先为线程栈定义一个线程控制块指针，用于存放线程创建时返回的线程控制块的地址&gt;&gt;&gt;**</span><br><span class="line">                        static rt_thread_t xxx_thread;</span><br><span class="line"> /**创建线程：  使用 rt_thread_create(); 来创建一个线程</span><br><span class="line">                |--&gt; 线程控制块指针</span><br><span class="line">                |--&gt;......其余的形参 【比较好理解】</span><br><span class="line">    启动线程：  线程初始化好后，是处于线程初始态(RT_THREAD_INIT),并不能参与操作系统的调度，只有线程进入就绪态(RT_THREAD_READY)之后才能参与操作系统的调度</span><br><span class="line">                线程由初始态进入就绪态可由函数rt_thread_startup(); 来实现               </span><br><span class="line">                if(xxx_thread != RT_NULL)</span><br><span class="line">                    rt_thread_startup(xxx_thread);</span><br><span class="line">                else</span><br><span class="line">                    return -1;</span><br></pre></td></tr></table></figure>
</code></pre>
<h2 id="2-重映射串口到rt-Kprintf函数"><a href="#2-重映射串口到rt-Kprintf函数" class="headerlink" title="2.重映射串口到rt_Kprintf函数"></a>2.重映射串口到rt_Kprintf函数</h2><pre><code>在RT-Thread中，rt_Kprintf()供用户使用，方便调试时输出各种信息
要想使用rt_Kprintf()，则必须将【控制台重映射】到 rt_Kprintf()，这个控制台可以是串口、CAN、USB、以太网等输出设备
</code></pre>
<p>rt_Kprintf()函数是属于内核服务类的函数—&gt;实现只需通过一个控制台将rt_log_buf缓冲区的内容发送出去即可<br>        |–&gt;通过rt_hw_console_output函数来实现串口控制台重映射到rt_Kprintf函数<br>    【就为一个打印函数】</p>
<p>启动RTOS操作系统，有2种方式：<br>                        |–&gt;1.先将所有线程给创建上，然后启动RTOS调度器把所有线程都开启调度<br>                        |–&gt;2.创建一个启动线程就启动调度器，然后在启动线程里面创建各种应用线程，当所有线程都创建成功后，启动线程把自己删除<br>                            [ 类似于主函数main(), 在主函数里创建了所有线程，然后main()函数没有while(1)循环，之后就不会进入主函数【类似于主函数自己删除了】 ]<br>        ucos第一/第二种都可以使用<br>        RT-Thread 和 FreeRTos 默认第二种【 RT-Thread 相对高级点 】</p>
<h2 id="3-线程管理"><a href="#3-线程管理" class="headerlink" title="3.线程管理"></a>3.线程管理</h2><pre><code>从系统上来看，线程是竞争系统资源的最小的运行单元
·············································
    在RT-Thread系统中，每个线程都有多种运行状态
    系统初始化完成后，创建的线程即可以在系统中竞争一定的资源
线程的状态：
    |--&gt;初始态：创建线程的时候会将线程的状态设置为初始态
    |--&gt;就绪态：该线程在就绪列表中，就绪线程具有执行的能力，等待CPU
    |--&gt;运行态：该线程正在执行，此时正占用CPU
    |--&gt;挂起态：线程正在等待某个时序/中断，即为处于挂起状态 【该线程不在就绪列表中】
    |--&gt;关闭态：该线程运行结束，等待系统回收资源
    
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">                                                                                          （运行结束会在线程最后部分执行函数而更改为关闭状态）</span><br><span class="line">                                                                            运行态 ———————————————————————————————————————————————————————————————&gt;  关闭态</span><br><span class="line">                                                                            |↑   |                 rt_thread_exit()                                    ↑</span><br><span class="line">                                                                     ︵ ︵  ||   |                                                                     | ︵ ︵</span><br><span class="line">                                                                     有 程  ||   |                                                                     | 处 接</span><br><span class="line">                                                                     更 发  ||   |                                                                     | 于 口</span><br><span class="line">                                                                     高 生  ||   |          rt_thread_delay()  rt_thread_suspend() rt_thread_yield()  fs | 挂 </span><br><span class="line">                                                                     优 线  ||   |  （运行的线程发生[挂起、延时、读信号量等]，线程会从就绪列表中删除）     | 起</span><br><span class="line">                                                                     先 程  ||   | ———————————————————————————————————————————————————————————————&gt;|   | 的</span><br><span class="line">                                                                     级 调  ||   |&lt;——————————————————————————————————————————————————————————————— |   | 线</span><br><span class="line">                                                                     创 度  ||    （线程被恢复后，被恢复的线程会被加入到就绪列表，                    |   | 程</span><br><span class="line">                                                                     建/    ||                           若优先级高，则发生线程切换而执行）          |   | 被</span><br><span class="line">                                                                     恢 仍  ||                                                                     |   | 调</span><br><span class="line">                                                                     复 在  ||                                                                     |   | 用</span><br><span class="line">                                                                     ， 就  ||                                                                     |   | 删</span><br><span class="line"> rt_thread_create()                                                  线 绪  ||                                                                     |   | 除</span><br><span class="line"> rt_thread_init()                                                    ︶ 列  ||        （线程从就绪列表中删除，不参与线程调度，直到线程被恢复）         |   | ︶</span><br><span class="line">（线程创建后即为初始态）                                                 表   ↓|                                                                     |   |</span><br><span class="line">    初始态 ———————————————————————————————————————————————————————————————&gt; 就绪态 ———————————————————————————————————————————————————————————————&gt;  挂起态</span><br><span class="line">                        rt_thread_startup()                                       &lt;———————————————————————————————————————————————————————————————</span><br><span class="line">                                                                (线程已经启动，线程可以进行调度)        （线程被恢复后，被恢复的线程会被加入到就绪列表）</span><br><span class="line">                                                                                             rt_thred_resume()   //线程恢复函数   </span><br><span class="line">                                                                                             [[调用恢复函数后要立即调用rt_schedule()进行手动的线程上下文切换]]</span><br></pre></td></tr></table></figure>
·············································
RT-Thread中 程序运行的上下文包括：
        1.中断服务函数  运行于非线程的执行环境下 &lt;优先级高于普通线程&gt;
        2.普通线程
        3.空闲线程  唯一一个不出现堵塞情况的线程，RTT需要保证系统有一个一直可运行的线程
</code></pre>
<h2 id="4-消息队列"><a href="#4-消息队列" class="headerlink" title="4.消息队列"></a>4.消息队列</h2><pre><code>    ~~~&gt; 类似于裸机下的一个全局数组
    消息队列：一种常用于线程间通信的数据结构  [[可在线程与线程间/线程与中断间传送信息]]
    消息队列是一种异步的通信方式，没有固定长度的消息
        通过消息队列服务，线程或中断服务例程可以将一条或多条消息放入消息队列中。一个或多个线程可以从消息队列中获得消息。
        当有多个消息发送到消息队列时，通常是将先进入消息队列的消息先传给线程，也就是说，线程先得到的是最先进入消息队列的消息，即先进先出原则(FIFO)。
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">    消息队列的运作机制:</span><br><span class="line">    创建消息队列时先创建一个消息队列对象控制块，然后给消息队列分配一块内存空间，组织成空闲消息链表，这块内存的大小等于[消息大小+消息头（用于链表连接）]与消息队列容量的乘积，接着再初始化消息队列，此时消息队列为空。</span><br><span class="line"></span><br><span class="line">RT-Thread 操作系统的消息队列对象由多个元素组成，当消息队列被创建时，它就被分配了消息队列控制块：消息队列名称、内存缓冲区、消息大小以及队列长度等。同时每</span><br><span class="line">个消息队列对象中包含着多个消息框，每个消息框可以存放一条消息；消息队列中的第一个和最后一个消息框被分别称为消息链表头和消息链表尾，对应于消息队列控制块中的</span><br><span class="line">msg_queue_head 和 msg_queue_tail；有些消息框可能是空的，它们通过 msg_queue_free 形成一个空闲消息框链表。所有消息队列中的消息框总数即是消息队列的长度，这个长度可</span><br><span class="line">在消息队列创建时指定。</span><br><span class="line"></span><br><span class="line">        线程或者中断服务程序都可以给消息队列发送消息。当发送消息时，消息队列对象先从空闲消息链表上取下一个空闲消息块，把线程或者中断服务程序发送的消息内容复制到</span><br><span class="line">    消息块上，然后把该消息块挂到消息队列的尾部。当且仅当空闲消息链表上有可用的空闲消息块时，发送者才能成功发送消息；当空闲消息链表上无可用消息块，说明消息队列已</span><br><span class="line">    满，此时，发送消息的的线程或者中断程序会收到一个错误码（-RT_EFULL）。</span><br><span class="line">        发送紧急消息的过程与发送消息几乎一样，唯一的不同是，当发送紧急消息时，从空闲消息链表上取下来的消息块不是挂到消息队列的队尾，而是挂到队首，这样，接收者就能够优先接收到紧急消</span><br><span class="line">    息，从而及时进行消息处理。</span><br><span class="line">        读取消息时，根据 msg_queue_head 找到最先入队列中的消息节点进行读取。根据消息队列控制块中的 entry 判断队列是否有消息读取，对全部空闲（entry 为 0）队列进行读消息</span><br><span class="line">    操作会引起线程挂起。</span><br><span class="line">        当消息队列不再被使用时，应该删除它以释放系统资源，一旦操作完成，消息队列将被永久性的删除。</span><br><span class="line">  </span><br><span class="line">    ················································································</span><br><span class="line">    |———————————|        |——————————————————————————————————|                           </span><br><span class="line">    |  空闲链表  |        |  消息队列控制块：(消息队列名称...) |</span><br><span class="line">    |———————————|        |  多个消息框 :(每个可存放一条消息)  |</span><br><span class="line">    | 消息链表头 |        |  ————    ————        —————       |</span><br><span class="line">    |———————————|        |  | 头|   |空~ |  ... | 尾 |       |</span><br><span class="line">    | 消息链表尾 |        |  ————    ————        —————       |</span><br><span class="line">    |———————————|        |——————————————————————————————————|</span><br><span class="line">   (消息队列控制块)            (给消息队列分配的内存空间)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
消息队列的阻塞机制：
【消息队列一般不是属于某个线程的队列，我们创建的队列，是每个线程都可以去对他进行读写操作的，但是为了保护每个线程对它进行读写操作的过程，我们必须要有阻塞机制，在某个线程对它读写操作的时候，必须保证该线程能正常完成读写操作，而不受后来的线程干扰】

··············································································
RT-Thread 已经做好了，直接使用就好，每个对消息队列读写的函数，都有这种机制，称之为阻塞机制。
    机制的3种方式：
    |    -----------------------------------------------------------
    |    假设有一个线程 A 对某个队列进行读操作的时候（也就是我们所说的出队），发现它没有消息，那么此时线程 A 有 3 个选择：
    |--&gt; 1.  第一个选择，线程 A 扭头就走，既然队列没有消息，那我也不等了，干其它事情去，这样子线程 A 不会进入阻塞态；
    |--&gt; 2.  第二个选择，线程 A 还是在这里等等吧，可能过一会队列就有消息，此时线程 A 会进入阻塞状态，在等待着消息的道来，而线程 A 的等待时间就由我们自己定义，比如设置 1000 
    |    个 tick 的等待，在这 1000个 tick 到来之前线程 A 都是处于阻塞态，当阻塞的这段时间线程 A 等到了队列的消息，那么线程 A 就会从阻塞态变成就绪态，如果此时线程 A 比当前运
    |    行的线程优先级还高，那么，线程 A 就会得到消息并且运行；假如 1000 个 tick 都过去了，队列还没消息，那线程 A 就不等了，从阻塞态中唤醒，返回一个没等到消息的错误代码，然
    |    后继续执行线程 A 的其他代码；
    |--&gt; 3. 第三个选择，线程 A 死等，不等到消息就不走了，这样子线程 A 就会进入阻塞态，直到完成读取队列的消息

//*在发送消息操作的时候，为了保护数据，当且仅当空闲消息链表上有可用的空闲消息块时，发送者才能成功发送消息；当空闲消息链表上无可用消息块，说明消息队列已满，此时，发送消息的的线程或者中断程序会收到一个错误码（-RT_EFULL），发送消息并不带有阻塞机制的，因为发送消息的环境可能是在中断中，不允许有阻塞的情况。*\\
··············································································
消息队列控制块包含了每个消息队列的信息，如消息队列名称、内存缓冲区、消息大小以及队列长度等，是很重要的一个内核对象控制块
    struct rt_messagequeue &#123;
    struct rt_ipc_object parent;        //一个内核对象类型的成员，通过这个成员可以将消息队列挂到系统对象容器里面
    
    void *msg_pool;                     //存放消息的消息池开始地址
    
    rt_uint16_t msg_size;               //每条消息大小
    rt_uint16_t max_msgs;               //能够容纳的最大消息数量
    
    rt_uint16_t entry;                  //队列中的消息索引，记录消息队列的消息个数
    
    void *msg_queue_head;               //链表头指针，指向即将读取数据的节点
    void *msg_queue_tail;               //链表尾指针，指向允许写入数据的节点
    void *msg_queue_free;               //指向队列的空闲节点的指针
    &#125;;
    typedef struct rt_messagequeue *rt_mq_t;
常用消息队列的函数:
        ① 创建消息队列:    rt_mq_create() 
        ② 写队列操作函数:  rt_mq_send() 
        ③ 读队列操作函数:  rt_mq_recv() 
        ④ 删除队列:       rt_mq_delete()
【消息队列使用注意事项：
1. 队列读取采用的是先进先出（FIFO）模式，会首先读取出首先存储在队列中的数据
2. 必须要我们定义一个存储读取出来的数据的地方，并且把存储数据的起始地址传递给 rt_mq_recv()函数，否则，将发生地址非法的错误
3. 接收消息队列中的消息是拷贝的方式，读取消息时候定义的地址必须保证能存放下即将读取消息的大小
】
</code></pre>
<h2 id="5-信号量"><a href="#5-信号量" class="headerlink" title="5.信号量"></a>5.信号量</h2><pre><code>    ~~~&gt; 类似于裸机中一个变量，用于标记某个事件发生的标志位
信号量是一种实现线程间通信的机制
实现线程之间同步或临界资源的互斥访问，&lt;常用于协助一组相互竞争的线程来访问临界资源&gt;
通常一个信号量的计数值用于对应有效的资源数，表示剩下的可被占用的互斥资源数

以同步为目的的信号量和以互斥为目的的信号量在使用有如下不同：
  
  用作互斥时，信号量创建后可用信号量个数应该是满的，线程在需要使用临界资源时，先获取信号量，使其变空，这样其他线程需要使用临界资源时就会因为无法获取信号量而进入阻塞，从而保证了临界资源的安全。但是这样子有一个缺点就是有可能产生优先级翻转，优先级翻转的危害具体会在互斥量章节中详细讲解。
  
  用作同步时，信号量在创建后被置为空，线程 1 取信号量而阻塞挂起，线程 2 在某种条件发生后，释放信号量，于是线程 1 得以进入就绪态，如果线程 1 的优先级是最高的，那么就会立即切换线程，从而达到了两个线程间的同步。同样的，在中断服务函数中释放信号量，也能达到线程与中断间的同步。

**在操作系统中，我们使用信号量的目的是为了给临界资源建立一个标志，信号量表示了该临界资源被占用情况。这样，当一个线程在访问临界资源的时候，就会先对这个资源信息进行查询，从而在了解资源被占用的情况之后，再做处理，从而使得临界资源得到有效的保护**

便于理解：
    在裸机开发中我们经常是在中断中做一个标记，然后在退出的时候进行轮询处理，这个就是类似我们使用信号量进行同步的，当标记发生了，我们再做其他事情。在 RT-Thread 我们用信号量用于同步，线程与线程的同步，中断与线程的同步，可以大大提高效率

二值信号量： 是线程间、线程与中断间同步的重要手段
    |--&gt; 信号量资源被获取，信号量值就是 0
    |--&gt; 信号量资源被释放，信号量值就是 1

[当没有数据到来的时候，线程就进入阻塞态，不参与线程的调度，等到数据到来了，释放一个二值信号量，线程就立即从阻塞态中解除，进入就绪态，然后运行的时候处理数据，这样子系统的资源就会很好的被利用起来]
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">二值信号量的运作机制:</span><br><span class="line">    创建二值信号量，为创建的信号量对象分配内存，并把可用信号量初始化为用户自定义的个数， 二值信号量的最大可用信号量个数为 1</span><br><span class="line">        信号量获取，从创建的信号量资源中获取一个信号量，获取成功返回正确。否则线程会等待其它线程释放该信号量，超时时间由用户设定。当线程获取信号量失败时，线程将进入阻塞态，系统将线程挂到该信号量的阻塞列表中。</span><br><span class="line">        假如某个时间中断/线程释放了信号量,由于获取无效信号量而进入阻塞态的线程将获得信号量并且恢复为就绪态</span><br><span class="line">计数型信号量的运作机制:</span><br><span class="line">    计数型信号量与二值信号量其实都是差不多的，一样用于资源保护，不过计数信号量则允许多个线程获取信号量访问共享资源，但会限制线程的最大数目。访问的线程数达到信号量可支持的最大数目时，会阻塞其他试图获取该信号量的线程，直到有线程释放了信号量</span><br></pre></td></tr></table></figure>
信号量控制块:
    struct rt_semaphore &#123;
    struct rt_ipc_object parent;     /**&lt; 继承自 ipc_object 类*/
    
    rt_uint16_t value;               /**&lt; 信号量的值，最大为 65535 */
    &#125;;
    typedef struct rt_semaphore *rt_sem_t;
常用信号量函数:
    信号量创建函数: rt_sem_create(const char *name,rt_uint32_t value,rt_uint8_t flag)   //  信号量名称 , 可用信号量初始值 ,
                                                                                          信号量模式（RT_IPC_FLAG_PRIO：优先级高的线程优先获得资源）
                                                                                                   （RT_IPC_FLAG_FIFO：先来先得的顺序获得资源）
                【在创建信号量的时候，是需要用户自己定义信号量控制块】
            <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* 定义信号量控制块 */</span><br><span class="line">static rt_sem_t test_sem = RT_NULL;</span><br><span class="line">/* 创建一个信号量 */</span><br><span class="line">test_sem = rt_sem_create(&quot;test_sem&quot;,/* 信号量名字 */ </span><br><span class="line">                           1, /* 信号量初始值，默认有一个信号量 */ </span><br><span class="line">                           RT_IPC_FLAG_FIFO); /* 信号量模式 FIFO(0x00)*/ </span><br><span class="line">if (test_sem != RT_NULL)</span><br><span class="line">rt_kprintf(&quot;信号量创建成功！\n\n&quot;);</span><br></pre></td></tr></table></figure>
    信号量删除函数： rt_sem_delete(rt_sem_t sem)       //形参为用户自己定义信号量控制块   ---&gt;  删除之后这个信号量的所有信息都会被系统回收
    信号量释放函数:  rt_sem_release(rt_sem_t sem)      
            当信号量有效的时候，线程才能获取信号量，在二进制信号量中，该初始值的范围是 0~1，假如初始值为 1 个可用的信号量的话，被申请一次就变得无效了，那就需要我们释放信号量
            每调用一次该函数就释放一个信号量
            【该函数将释放一个信号量，当信号量的值等于零时，并且有线程等待这个信号量时， 释放信号量将唤醒等待在该信号量线程队列中的第一个线程，由它获取信号量；否则 将把信号量的值加一】
            <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static void send_thread_entry(void* parameter)</span><br><span class="line">&#123;</span><br><span class="line">rt_err_t uwRet = RT_EOK;</span><br><span class="line">/* 线程都是一个无限循环，不能返回 */</span><br><span class="line">while (1) &#123; //如果 KEY2 被单击</span><br><span class="line">if ( Key_Scan(KEY2_GPIO_PORT,KEY2_GPIO_PIN) == KEY_ON ) &#123; </span><br><span class="line">/* 释放一个计数信号量 */ </span><br><span class="line">uwRet = rt_sem_release(test_sem); </span><br><span class="line">if ( RT_EOK == uwRet ) </span><br><span class="line">rt_kprintf ( &quot;KEY2 被单击：释放 1 个停车位。\r\n&quot; ); </span><br><span class="line">else</span><br><span class="line">rt_kprintf ( &quot;KEY2 被单击：但已无车位可以释放！\r\n&quot; );</span><br><span class="line">&#125;</span><br><span class="line">rt_thread_delay(20); //每 20ms 扫描一次</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    信号量获取函数:  rt_sem_take(rt_sem_t sem, rt_int32_t time))        // 用户自己定义信号量控制块  ， 指定的等待时间        
            当线程获取了某个信号量的时候，该信号量的有效值就会减一,即为该信号量的可用个数就减一，当它减到 0 的时候，线程就无法再获取了，并且获取的线程会进入阻塞态（假如使用了等待时间的话）
            每调用一次 rt_sem_take()函数获取信号量的时候，信号量的可用个数便减少一个，直至为 0 的时候，线程就无法成功获取信号量了
            【获取该信号量的线程将根据 time 参数的情况选择直接返回、或挂起等待一段时间、或永久等待，直到其他线程或中断释放该信号量】
            <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rt_sem_take(test_sem,            /* 获取信号量 */ </span><br><span class="line">            RT_WAITING_FOREVER); /* 等待时间：一直等 */ </span><br><span class="line"></span><br><span class="line">uwRet = rt_sem_take(test_sem, /* 获取一个计数信号量 */ </span><br><span class="line">                    0);       /* 等待时间：0 */ </span><br><span class="line">if ( RT_EOK == uwRet )</span><br><span class="line">rt_kprintf( &quot;获取信号量成功\r\n&quot; );</span><br></pre></td></tr></table></figure>
</code></pre>
<h2 id="6-互斥量"><a href="#6-互斥量" class="headerlink" title="6.互斥量"></a>6.互斥量</h2><pre><code>|--&gt; 互斥型信号量，是一种特殊的二值信号量 (它支持互斥量所有权、递归访问以及防止优先级翻转的特性，用于实现对临界资源的独占式处理)
    |--&gt; 互斥量更多的是用于保护资源的互锁
        |--&gt; RT-Thread 提供的互斥量通过优先级继承算法，可用降低优先级翻转问题产生的影响

        任意时刻互斥量的状态只有两种，开锁或闭锁。
        当互斥量被线程持有时，该互斥量处于闭锁状态，这个线程获得互斥量的所有权。
        当该线程释放这个互斥量时，该互斥量处于开锁状态，线程失去该互斥量的所有权。
        当一个线程持有互斥量时，其他线程将不能再对该互斥量进行开锁或持有。持有该互斥量的线程也能够再次获得这个锁而不被挂起，这就是递归访问，这个特性与一般的二值信号量有很大的不同，在信号量中，由于已经不存在可用的信号量，线程递归获取信号量时会发生主动挂起（最终形成死锁）。

优先级继承算法:暂时提高某个占有某种资源的低优先级线程的优先级，使之与在所有等待该资源的线程中优先级最高那个线程的优先级相等，而当这个低优先级线程执行完毕释放该资源时，优先级重 
              新回到初始设定值。因此，继承优先级的线程避免了系统资源被任何中间优先级的线程抢占。
        ··············································································

        若某个临界资源受到一个互斥量保护，如果这个资源正在被一个低优先级线程使用，那么此时的互斥量是闭锁状态，也代表了没有线程能申请到这个互斥量，如果此时一个高优先级线程想要
        对这个资源进行访问，去申请这个互斥量，那么高优先级线程会因为申请不到互斥量而进入阻塞态，那么系统会将现在持有该互斥量的线程的优先级临时提升到与高优先级线程的优先级相
        同，这个优先级提升的过程叫做优先级继承
        
        ··············································································
        在初始化的时候，互斥量处于开锁的状态，而被线程持有的时候则立刻转为闭锁的状态
        ··············································································
        互斥量的运作机制：
            用互斥量处理不同线程对临界资源的同步访问时，线程想要获得互斥量才能进行资源
            访问，如果一旦有线程成功获得了互斥量，则互斥量立即变为闭锁状态，此时其他线程会
            因为获取不到互斥量而不能访问这个资源，线程会根据用户自定义的等待时间进行等待，
            直到互斥量被持有的线程释放后，其他线程才能获取互斥量从而得以访问该临界资源，此
            时互斥量再次上锁，如此一来就可以确保每个时刻只有一个线程正在访问这个临界资源，
            保证了临界资源操作的安全性
        ··············································································
    互斥量控制块：
        struct rt_mutex &#123;
        struct rt_ipc_object parent;      //一个内核对象类型的成员，通过这个成员可以将互斥量挂到系统对象容器里面
        
        rt_uint16_t value;                //互斥量的值，如果值大于 0，表示可以使用互斥量
        
        rt_uint8_t original_priority;     //持有互斥量线程的原始优先级，用来做优先级继承的保存
        rt_uint8_t hold;                  //持有互斥量的线程的持有次数，用于记录线程递归调用了多少次获取互斥量
        
        struct rt_thread *owner;          //当前持有互斥量的线程
        &#125;;
        typedef struct rt_mutex *rt_mutex_t;
    常用互斥量函数：
        互斥量创建函数： rt_mutex_create(const char *name, rt_uint8_t flag)        //用户自己定义互斥量控制块， 互斥量的等待模式
        互斥量删除函数： rt_mutex_delete(rt_mutex_t mutex)                         //用户自己定义互斥量控制块
        互斥量释放函数： rt_mutex_release(rt_mutex_t mutex)
                                                       //只有已持有互斥量所有权的线程才能释放它，每释放一次该互斥
                                    量，它的持有计数就减 1。当该互斥量的持有计数为零时（即持有线程已经释放所有的持
                                    有操作），互斥量则变为开锁状态，等待在该互斥量上的线程将被唤醒。如果线程的优先
                                    级被互斥量的优先级翻转机制临时提升，那么当互斥量被释放后，线程的优先级将恢复为
                                    原本设定的优先级
        互斥量获取函数： rt_mutex_take(rt_mutex_t mutex , rt_int32_t time)         //用户自己定义互斥量控制块， 互斥量的等待时间
                                                    //线程对互斥量的所有权是独占的，任意时刻互斥量只能被一个线程持有，如果互斥量处于开锁
                                                    状态，那么获取该互斥量的线程将成功获得该互斥量，并拥有互斥量的使用权；如果互斥量处
                                                    于闭锁状态，获取该互斥量的线程将无法获得互斥量，线程将被挂起，直到持有互斥量线程释
                                                    放它，而如果线程本身就持有互斥量，再去获取这个互斥量却不会被挂起，只是将该互斥量的持有值加 1
        **互斥量不能在中断服务程序中使用**
</code></pre>
<h2 id="7-事件"><a href="#7-事件" class="headerlink" title="7.事件"></a>7.事件</h2><pre><code>    |--&gt;事件仅用于同步，不提供数据传输功能 / 允许多个线程对同一事件进行读写操作
    可以用事件来做标志位，判断某些事件是否发生了，然后根据结果做处理
    事件是一种实现线程间通信的机制，主要用于实现线程间的同步，但事件通信只能是事件类型的通信，无数据传输
        //它可以实现一对多，多对多的同步。即一个线程可以等待多个事件的发生：可以是任意一个事件发生时唤醒线程进行事件处理；
        也可以是几个事件都发生后才唤醒线程进行事件处理。同样，事件也可以是多个线程同步多个事件。\\
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    事件集合用 32 位无符号整型变量来表示，每一位代表一个事件，线程通过“逻辑与”或“逻辑或”与一个或多个事件建立关联，形成一个事件集
            |--&gt; 事件的“逻辑或”也称作是独立型同步，指的是线程感兴趣的所有事件任一件发生即可被唤醒
            |--&gt; 事件的“逻辑与”也称为是关联型同步，指的是线程感兴趣的若干事件都发生时才被唤醒
        &lt;线程可以通过创建事件来实现事件的触发和等待操作&gt;
        ··················································
        事件的运作机制：
        接收事件时，可以根据感兴趣的参事件类型接收事件的单个或者多个事件类型。事件接收成功后，必须使用 RT_EVENT_FLAG_CLEA 选项来清除已接收到的事件类型，否则不会清除已接收到的事件。用户可以自定义通过传入参数选择读取模式 option，是等待所有感兴趣的事件还是等待感兴趣的任意一个事件。
        发送事件时，对指定事件写入指定的事件类型，设置事件集合 set 的对应事件位为 1，可以一次同时写多个事件类型，发送事件会触发线程调度。
        清除事件时，根据入参数事件句柄和待清除的事件类型，对事件对应位进行清 0 操作。
        事件不与线程相关联，事件相互独立，一个 32 位的变量（事件集合 set），用于标识该线程发生的事件类型，其中每一位表示一种事件类型（0 表示该事件类型未发生、1 表示该事
        件类型已经发生），一共 32 种事件类型
        ··················································
    事件控制块：
            struct rt_event &#123;
            struct rt_ipc_object parent; 
            
            rt_uint32_t set;                       /**&lt; 事件标志位 */
            &#125;;
            typedef struct rt_event *rt_event_t;   /* rt_event_t 是指向事件结构体的指针 */
    常见事件函数：
            事件创建函数： rt_event_create(const char *name, rt_uint8_t flag)      //用户自己定义的事件控制块 ， 事件阻塞唤醒模式【RT_IPC_FLAG_PRIO/RT_IPC_FLAG_FIFO】
            事件删除函数： rt_event_delete(rt_event_t event)      //用户自己定义的事件控制块
            事件发送函数： rt_event_send(rt_event_t event , rt_uint32_t set)
                                //通过参数 set 指定的事件标志来设定事件的标志位，然后遍历等
                                待在 event 事件对象上的等待线程链表，判断是否有线程的事件激活要求与当前事件对象
                                标志值匹配，如果有，则唤醒该线程。简单来说，就是设置我们自己定义的事件标志位为 1
                                并且看看有没有线程在等待这个事件，有的话就唤醒它
            事件接受函数： rt_event_recv(rt_event_t event, rt_uint32_t set, rt_uint8_t option, rt_int32_t timeout, rt_uint32_t *recved)
                                //option ： 接收选项 ， 有 RT_EVENT_FLAG_AND 、RT_EVENT_FLAG_OR，可以与 RT_EVENT_FLAG_CLEAR 通过“|”按位或操作符连接使用
                                //timeout： 是设置等待的超时时间。
                                //recved ： 用于保存接收到的事件标志结果，用户通过它的值判断是否成功接收到事件
                eg:
                    static void receive_thread_entry(void* parameter)
                    &#123;
                    rt_uint32_t recved;
                    /* 线程都是一个无限循环，不能返回 */
                    while (1) &#123;
                    /* 等待接收事件标志 */ 
                    rt_event_recv(test_event, /* 事件对象句柄 */ 
                                    KEY1_EVENT|KEY2_EVENT, /* 接收线程感兴趣的事件 */ 
                                    RT_EVENT_FLAG_AND|RT_EVENT_FLAG_CLEAR,/* 接收选项 */ 
                                    RT_WAITING_FOREVER, /* 指定超时事件,一直等 */ 
                                    &amp;recved); /* 指向接收到的事件 */ 
                    if (recved == (KEY1_EVENT|KEY2_EVENT)) &#123; /* 如果接收完成并且正确 */ 
                    rt_kprintf ( &quot;Key1 与 Key2 都按下\n&quot;);
                    LED1_TOGGLE; //LED1 反转
                    &#125; else
                    rt_kprintf ( &quot;事件错误！\n&quot;);
                    &#125;
</code></pre>
<h2 id="8-软件定时器："><a href="#8-软件定时器：" class="headerlink" title="8.软件定时器："></a>8.软件定时器：</h2><pre><code>    软件定时器是由操作系统提供的一类系统接口，它构建在硬件定时器基础之上，使系统能够提供不受硬件定时器资源限制的定时器服务，它实现的功能与硬件定时器也是类似
    使用软件定时器，需要我们在创建软件定时器时指定时间到达后要调用的超时函数，在超时函数中处理信息
    软件定时器在被创建之后，当经过设定的时钟计数值后会触发用户定义的超时函数。
    【软件定时器与 定时精度 和 系统时钟的周期有关】
    超时函数类似硬件的中断服务函数，超时函数也要快进快出，而且超时函数中不能有任何阻塞线程运行的情况
    两次触发超时函数的时间间隔 Tick 叫定时器的定时周期
    ···············································································
    RT-Thread 提供的软件定时器支持 单次模式和周期模式
        单次模式：当用户创建了定时器并启动了定时器后，定时时间到了，只执行一次超时函数之后就将该定时器删除，不再重新执行
        周期模式：这个定时器会按照设置的定时时间循环执行超时函数，直到用户将定时器删除
    ···············································································
    软件定时器的精度是无法和硬件定时器相比的，因为在软件定时器的定时过程中是极有可能被其它的线程所打断，因为软件定时器的线程优先级是 RT_TIMER_THREAD_PRIO，默认为 4。所以，软件定时器更适用于对时间精度要求不高的线程，一些辅助型的线程
        |--&gt;[系统节拍周期的值越小，精度越高，但是系统开销也将越大，因为在 1 秒中系统进入时钟中断的次数也就越多]
软件定时器的运作机制:
    软件定时器是系统资源，在创建定时器的时候会分配一块内存空间。当用户创建并启动一个软件定时器时， RT-Thread 会根据当前系统 rt_tick 时间及用户设置的定时确定该定时器唤醒时间 timeout，并将该定时器控制块挂入软件定时器列表 rt_soft_timer_list
        在 RT-Thread 定时器模块中维护着两个重要的全局变量:
            |--&gt; rt_tick，它是一个 32 位无符号的变量，用于记录当前系统经过的 tick 时间，当硬件定时器中断来临时，它将自动增加 1
            |--&gt; rt_soft_timer_list  软件定时器列表 
                        |--&gt; 系统新创建并激活的定时器都会以超时时间升序的方式插入到 rt_soft_timer_list列表中.系统在定时器线程中扫描 rt_soft_timer_list 中的第一个定时器，看
                             是否已超时，若已经超时了则调用软件定时器超时函数, 否则出软件定时器线程
        软件定时器时候要注意:
                 软件定时器的超时函数中应快进快出，绝对不允许使用任何可能引软件定时器起线程挂起或者阻塞的 API 接口，在超时函数中也绝对不允许出现死循环。
                 软件定时器使用了系统的一个队列和一个线程资源，软件定时器线程的优先级默认为 RT_TIMER_THREAD_PRIO。 
                 创建单次软件定时器，该定时器超时执行完超时函数后，系统会自动删除该软件定时器，并回收资源。
                 定时器线程的堆栈大小默认为 RT_TIMER_THREAD_STACK_SIZE，512 个字节。
        <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">软件定时器的使用:</span><br><span class="line">    软件定时器创建函数: rt_timer_create(const char *name,                   //用户自定义的软件定时器名称</span><br><span class="line">                                        void (*timeout)(void *parameter),  //定时器超时函数指针（当定时器超时时，系统会调用这个指针指向的函数），函数主体由用户自</span><br><span class="line">                                                                             己实现</span><br><span class="line">                                        void *parameter,                   //定时器超时函数的入口参数（当定时器超时时，调用超时函数会把这个参数做为入口参数传递给</span><br><span class="line">                                                                              超时函数）</span><br><span class="line">                                        rt_tick_t time,                    //定时器的超时时间</span><br><span class="line">                                        rt_uint8_t flag)                   //当指定的 flag 为RT_IMER_FLAG_HARD_TIMER 时，如果定时器超时，定时器的超时函数将在中</span><br><span class="line">                                                                            断中被调用（硬件定时器）；当指定的 flag 为 RT_TIMER_FLAG_SOFT_TIMER 时，如果定时器超时，定时器的超时函数将在线程中被调用（软件定时器）</span><br></pre></td></tr></table></figure>
    ·······················································································
    eg: 软件定时器实验
         #include &quot;board.h&quot;
         #include &quot;rtthread.h&quot;

         /* 定义线软件定时器制块 */
         static rt_timer_t swtmr1 = RT_NULL; 
         static rt_timer_t swtmr2 = RT_NULL;

         /* 当我们在写应用程序的时候，可能需要用到一些全局变量 */
         static uint32_t TmrCb_Count1 = 0;
         static uint32_t TmrCb_Count2 = 0;

         /*函数声明*/
         static void swtmr1_callback(void* parameter);
         static void swtmr2_callback(void* parameter);

         /*main 函数*/
        int main(void)
        &#123;
        
        /*
        * 开发板硬件初始化，RTT 系统初始化已经在 main 函数之前完成，
        * 即在 component.c 文件中的 rtthread_startup()函数中完成了。
        * 所以在 main 函数中，只需要创建线程和启动线程即可。
        */
        rt_kprintf(&quot;这是一个[野火]- STM32 全系列开发板-RTT 软件定时器实验！\n&quot;);
        rt_kprintf(&quot;定时器超时函数 1 只执行一次就被销毁\n&quot;);
        rt_kprintf(&quot;定时器超时函数 2 则循环执行\n&quot;);

        /* 创建一个软件定时器 */ 
        swtmr1 = rt_timer_create(&quot;swtmr1_callback&quot;, /* 软件定时器的名称 */ 
                                swtmr1_callback,/* 软件定时器的超时函数 */ 
                                    0, /* 定时器超时函数的入口参数 */ 
                                    5000, /* 软件定时器的超时时间(周期超时时间) */ 
                                RT_TIMER_FLAG_ONE_SHOT | RT_TIMER_FLAG_SOFT_TIMER);    /* 软件定时器模式 一次模式 */ 

        /* 启动定时器 */ 
        if (swtmr1 != RT_NULL) 
        rt_timer_start(swtmr1); 
        
        /* 创建一个软件定时器 */ 
        swtmr2 = rt_timer_create(&quot;swtmr2_callback&quot;, /* 软件定时器的名称 */ 
                                    swtmr2_callback,/* 软件定时器的超时函数 */
                                    0, /* 定时器超时函数的入口参数
                                    1000, /* 软件定时器的超时时间(周期超时时间) */
                                    RT_TIMER_FLAG_PERIODIC | RT_TIMER_FLAG_SOFT_TIMER);

        /* 启动定时器 */
        if (swtmr2 != RT_NULL)
        rt_timer_start(swtmr2);
        &#125;

        /*线程定义*/
        static void swtmr1_callback(void* parameter)
        &#123;
                uint32_t tick_num1; 
        
                TmrCb_Count1++; /* 每调用一次加一 */ 
        
                tick_num1 = (uint32_t)rt_tick_get(); /* 获取滴答定时器的计数值 */ 
        
                rt_kprintf(&quot;swtmr1_callback 函数执行 %d 次\n&quot;, TmrCb_Count1); 
                rt_kprintf(&quot;滴答定时器数值=%d\n&quot;, tick_num1); 
        &#125;
        static void swtmr1_callback(void* parameter)
        &#123;
                uint32_t tick_num2; 
        
                TmrCb_Count2++; /* 每调用一次加一 */ 
        
                tick_num2 = (uint32_t)rt_tick_get(); /* 获取滴答定时器的计数值 */ 
        
                rt_kprintf(&quot;swtmr2_callback 函数执行 %d 次\n&quot;, TmrCb_Count2); 
                rt_kprintf(&quot;滴答定时器数值=%d\n&quot;, tick_num1); 
        &#125;
</code></pre>
<h2 id="9-邮箱"><a href="#9-邮箱" class="headerlink" title="9.邮箱"></a>9.邮箱</h2><pre><code>邮箱在操作系统中是一种常用的 IPC 通信方式，邮箱可以在线程与线程之间。中断与线程之间进行消息的传递，效率更高
|--&gt; 用来做线程与线程、中断与线程间的通信
[邮箱中的每一封邮件只能容纳固定的 4 字节内容,当需要在线程间传递比较大的消息时，可以把指向一个缓冲区的指针作为邮件发送到邮箱中]
            线程能够从邮箱里面读取邮件消息，当邮箱中的邮件是空时，根据用户自定义的阻塞时间决定是否挂起读取线程；
            当邮箱中有新邮件时，挂起的读取线程被唤醒，邮箱也是一种异步的通信方式

通过邮箱，线程或中断服务函数可以将一个或多个邮件放入邮箱中。同样，一个或多个线程可以从邮箱中获得邮件消息。
        当有多个邮件发送到邮箱时，通常应将先进入邮箱的邮件先传给线程，也就是说，线程先得到的是最先进入邮箱的消息，即先进先出原则(FIFO)，
        同时 RT-Thread 中的邮箱支持优先级，也就是说在所有等待邮件的线程中优先级最高的会先获得邮件
【当队列使用结束后，需要通过删除邮箱以释放内存】
·························································································
邮箱的运作机制：
    创建邮箱对象时会先创建一个邮箱对象控制块，然后给邮箱分配一块内存空间用来存
    放邮件，这块内存的大小等于邮件大小（4 字节）与邮箱容量的乘积，接着初始化接收邮
    件和发送邮件在邮箱中的偏移量，接着再初始化消息队列，此时消息队列为空

    当邮箱被创建时，它就被分配了邮箱控制块：邮箱名称、邮箱缓冲区起始地址、邮箱大小等。同时每个邮箱对象中包含着多个邮件框，每个邮件框可以存放一封邮件；所有邮箱中的邮件框总数即是邮箱的大小，这个大小可在邮箱创建时指定

    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    线程或者中断服务程序都可以给邮箱发送邮件，非阻塞方式的邮件发送过程能够安全</span><br><span class="line">的应用于中断服务中，中断服务函数、定时器向线程发送消息的有效手段，而阻塞方式的</span><br><span class="line">邮件发送只能应用于线程中。当发送邮件时，当且仅当邮箱还没满邮件的时候才能进行发</span><br><span class="line">送，如果邮箱已满，可以根据用户设定的等待时间进行等待，当邮箱中的邮件被收取而空</span><br><span class="line">出空间来时，等待挂起的发送线程将被唤醒继续发送的过程，当等待时间到了还未完成发</span><br><span class="line">送邮件，或者未设置等待时间，此时发送邮件失败，发送邮件的线程或者中断程序会收到</span><br><span class="line">一个错误码（-RT_EFULL）。线程发送邮件可以带阻塞，但在中断中不能采用任何带阻塞</span><br><span class="line">的方式发送邮件。</span><br><span class="line">接收邮件时，根据邮箱控制块中的 entry 判断队列是否有邮件，如果邮箱的邮件非空，</span><br><span class="line">那么可以根据 out_offset 找到最先发送到邮箱中的邮件进行接收。在接收时如果邮箱为空，</span><br><span class="line">如果用户设置了等待超时时间，系统会将当前线程挂起，当达到设置的超时时间，邮箱依</span><br><span class="line">然未收到邮件时，那么线程将被唤醒并返回-RT_ETIMEOUT。如果邮箱中存在邮件，那么</span><br><span class="line">接收线程将复制邮箱中的 4 个字节邮件到接收线程中。通常来说，邮件收取过程可能是阻</span><br><span class="line">塞的，这取决于邮箱中是否有邮件，以及收取邮件时设置的超时时间。</span><br><span class="line">当邮箱不再被使用时，应该删除它以释放系统资源，一旦操作完成，邮箱将被永久</span><br><span class="line">性的删除。</span><br></pre></td></tr></table></figure>
邮箱控制块：
    struct rt_mailbox &#123;
    struct rt_ipc_object parent;             //一个内核对象类型的成员，通过这个成员可以将邮箱挂到系统对象容器里面
    
    rt_uint32_t *msg_pool;                   //邮箱缓冲区的开始地址
    
    rt_uint16_t size;                        //邮箱缓冲区的大小
    
    rt_uint16_t entry;                       //邮箱中当前邮件的数目
    rt_uint16_t in_offset;                   //邮箱邮件的进偏移指针，指向空的邮件
    rt_uint16_t out_offset;                  //邮箱邮件的出偏移指针，如果邮箱中有邮件，则指向先进来的邮件
    
    rt_list_t suspend_sender_thread;         //发送线程的挂起等待链表
    &#125;;
    typedef struct rt_mailbox *rt_mailbox_t;
常用邮箱的函数：
        邮箱创建函数： rt_mb_create(const char *name,                  //邮箱名称
                                    rt_size_t size,                   //邮箱容量
                                    rt_uint8_t flag)                  //设置邮箱的阻塞唤醒模式
        邮箱删除函数： rt_mb_delete(rt_mailbox_t mb)                   //用户自定义的邮箱控制块
            邮箱邮件发送函数： rt_mb_send_wait(rt_mailbox_t mb，rt_uint32_t value,rt_int32_t timeout)（阻塞）       //mb 邮箱控制块，value 邮件内容，timeout 超时时间
            邮箱邮件发送函数： rt_mb_send (rt_mailbox_t mb, rt_uint32_t value)（非阻塞）       //mb 邮箱控制块，value 邮件内容
        邮箱邮件接收函数： rt_mb_recv(rt_mailbox_t mb, rt_uint32_t *value, rt_int32_t timeout)        //mb 邮箱控制块，value 邮件内容，timeout 超时时间
·························································································       
邮箱的应用技巧：
    |--&gt;  邮箱传递的结构体
    |       struct msg &#123;
    |       rt_uint8_t *data_ptr;          //指向数据的指针 data_ptr
    |       rt_uint32_t data_size;         //数据块长度的变量 data_size
    |       &#125;;
    |--&gt;  对结构体进行发送操作
    |    struct msg* msg_ptr;
    |    msg_ptr = (struct msg*)rt_malloc(sizeof(struct msg));    //申请结构体大小的内存空间
    |    msg_ptr-&gt;data_ptr = ...; /* 指向相应的数据块地址*/
    |    msg_ptr-&gt;data_size = len; /* 数据块的长度*/
    |    /* 发送这个消息指针给 mb 邮箱*/
    |    rt_mb_send(mb, (rt_uint32_t)msg_ptr);
    |--&gt;  对结构体进行接收操作
    |    struct msg* msg_ptr;
    |    if (rt_mb_recv(mb, (rt_uint32_t*)&amp;msg_ptr) == RT_EOK)
    |    &#123;
    |    /* 在接收线程处理完毕后，需要释放相应的内存块*/
    |    rt_free(msg_ptr);
    |    &#125;
</code></pre>
<h2 id="10-中断管理"><a href="#10-中断管理" class="headerlink" title="10.中断管理"></a>10.中断管理</h2><pre><code> 异常与中断：
    异常是指任何打断处理器正常执行，并且迫使处理器进入一个由有特权的特殊指令执行的事件。异常通常可以分成两类：同步异常和异步异常
            由内部事件（像处理器指令运行产生的事件）引起的异常称为同步异常
            由外部异常源产生的异常，是一个由外部硬件装置产生的事件引起的为异步异常
        **同步异常不同于异步异常的地方是事件的来源，同步异常事件是由于执行某些指令而从处理器内部产生的，而异步异常事件的来源是外部硬件装置**
    中断属于异步异常, 中断是指中央处理器 CPU 正在处理某件事的时候，外部发生了某一事件，请求 CPU 迅速处理，CPU 暂时中断当前的工作，转入处理所发生的事件，处理完后，再回到原来被
                        中断的地方，继续原来的工作 [[[中断能打断任意优先级的线程的运行，且中断只做简单的处理 , 调用中断屏蔽函数进入临界段的时候，也需快进快出]]]
    ------------------------------------------------------------------------------------------
            eg:
            按下设备某个按钮产生的事件。同步异常与异步异常的区别还在于，同步异常触发后，系统必须立刻进行处理而不能够依然执行原有的程序指令步骤；而异步异常则可以延缓处理甚至是忽略，例如按键中断异常，虽然中断异常触发了，但是系统可以忽略它继续运行（同样也忽略了相应的按键事件）
    ------------------------------------------------------------------------------------------

    外设 --------------------------&gt;  中断控制器  ------------------------------------------------&gt;  CPU
        (请求CPU时，产生一个中断信号)              (接收外设的中断信号的输入，给CPU发出中断信号)        (响应中断源的请求)

中断相关的名词：
    中断号：每个中断请求信号都会有特定的标志，使得计算机能够判断是哪个设备提出的中断请求，这个标志就是中断号。
    中断请求：“紧急事件”需向 CPU 提出申请，要求 CPU 暂停当前执行的线程，转而处理该“紧急事件”，这一申请过程称为中断请求。
    中断优先级：为使系统能够及时响应并处理所有中断，系统根据中断时间的重要性和紧迫程度，将中断源分为若干个级别，称作中断优先级。
    中断处理程序：当外设产生中断请求后，CPU 暂停当前的线程，转而响应中断申请，即执行中断处理程序。
    中断触发：中断源发出并送给 CPU 控制信号，将中断触发器置“1”，表明该中断源产生了中断，要求 CPU 去响应该中断，CPU 暂停当前线程，执行相应的中断处理程序。
    中断触发类型：外部中断申请通过一个物理信号发送到 NVIC，可以是电平触发或边沿触发。
    中断向量：中断服务程序的入口地址。
    中断向量表：存储中断向量的存储区，中断向量与中断号对应，中断向量在中断向量表中按照中断号顺序存储。
    临界段：代码的临界段也称为临界区，一旦这部分代码开始执行，则不允许任何中断打断。为确保临界段代码的执行不被中断，在进入临界段之前须关中断，而临界段代码执行完毕后，要立即开中
            断。RT-Thread 支持中断屏蔽和中断使能。

中断管理的运作机制：
                    当中断产生时，处理机将按如下的顺序执行：
                                    1. 保存当前处理机状态信息
                                    2. 载入异常或中断处理函数到 PC 寄存器
                                    3. 把控制权转交给处理函数并开始执行
                                    4. 当处理函数执行完成时，恢复处理器状态信息
                                    5. 从异常或中断中返回到前一个程序执行点
                    通过两条特殊指令：关中断和开中断可以让处理器不响应或响应中断，在关闭中断期间，通常处理器会把新产生的中断挂起，当中断打开时立刻进行响应，所以会有适当的延时响应中断，故用户在进入临界区的时候应快进快出

RT-Thread 允许中断嵌套，即在一个中断服务例程期间，处理器可以响应另外一个优先级更高的中断
    中断的处理过程是：
        识别中断时间：外界硬件发生了中断后，CPU 到中断处理器读取中断向量，并且查找中断向量表，找到对应的中断服务子程序（ISR）的首地址，然后跳转到对应的ISR去做相应处理
        等待中断打开时间：在允许中断嵌套的实时操作系统中，中断也是基于优先级的，允许高优先级中断抢断正在处理的低优先级中断，所以，如果当前正在处理更高优先级的中断，即使
                        此时有低优先级的中断，也系统不会立刻响应，而是等到高优先级的中断处理完之后，才会响应。而即使在不支持中断嵌套，即中断是没有优先级的，中断是不允许被中断的，所以，如果当前系统正在处理一个中断，而此时另一个中断到来了，系统也是不会立即响应的，而只是等处理完当前的中断之后，才会处理后来的中断
        关闭中断时间： 在操作系统中，很多时候我们会主动进入临界段，系统不允许当前状态被中断打断，故而在临界区发生的中断会被挂起，直到退出临界段时候打开中断
            中断延迟 = 识别中断时间 + [等待中断打开时间] + [关闭中断时间]
eg:
中断管理——中断服务函数：
                /* 外部定义消息队列控制块 */
                extern rt_mq_t test_mq;

                uint32_t send_data = 1;

                /* 中断服务函数 */
                void KEY_IRQHandler(void) 
                &#123; 
                //确保是否产生了 EXTI Line 中断 
                if (EXTI_GetITStatus(KEY_INT_EXTI_LINE) != RESET)
                    &#123; 
                    /* 将数据写入（发送）到队列中，等待时间为 0 */ 
                    rt_mq_send( test_mq, /* 写入（发送）队列的 ID(句柄) */ 
                                &amp;send_data1, /* 写入（发送）的数据 */ 
                                sizeof(send_data1)); /* 数据的长度 */ 
                    //清除中断标志位 
                    EXTI_ClearITPendingBit(KEY1_INT_EXTI_LINE); 
                    &#125; 
                &#125;
</code></pre>
<h2 id="11-双向链表"><a href="#11-双向链表" class="headerlink" title="11.双向链表"></a>11.双向链表</h2><pre><code>    操作系统中常用的数据结构，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱，其头指针 head 是唯一确定的
    |--&gt;   由于双向链表具有对称性，能方便地完成各种插入、删除等操作，但需要注意前后方向的操作
常用双向链表的函数：
        链表节点结构体：
            struct rt_list_node &#123;
            struct rt_list_node *next; /**&lt; 指向下一个节点的指针. */
            struct rt_list_node *prev; /**&lt; 指向上一个节点的指针. */
            &#125;;
            typedef struct rt_list_node rt_list_t;
        链表初始化函数： rt_list_init(rt_list_t *l)
        向链表指定节点后面插入节点： rt_list_insert_after(rt_list_t *l, rt_list_t *n)
        向链表指定节点前面插入节点： rt_list_insert_before(rt_list_t *l, rt_list_t *n)
        从链表删除节点函数： rt_list_remove(rt_list_t *n)
</code></pre>
<h2 id="12-内存管理"><a href="#12-内存管理" class="headerlink" title="12.内存管理"></a>12.内存管理</h2><pre><code>        动态内存：在动态内存池中分配用户指定大小的内存块。
         优点：按需分配，在设备中灵活使用。 
         缺点：内存池中可能出现碎片。
        
        静态内存：在静态内存池中分配用户初始化时预设（固定）大小的内存块。
         优点：分配和释放效率高，静态内存池中无碎片。
         缺点：只能申请到初始化预设大小的内存块，不能按需申请。

动态分配内存与静态分配内存的区别：静态内存一旦创建就指定了内存块的大小，分配只能以内存块大小粒度进行分配；动态内存分配则根据运行时环境确定需要的内存块大小，按照需要分配内存。
    静态内存管理的函数：
    静态内存的典型场景开发流程：
        1. 规划一片内存区域作为静态内存池。
        2. 调用 rt_mp_create()函数。进行静态内存使用前的创建。
        3. 调用 rt_mp_alloc()函数。系统内部将会从空闲链表中获取第一个空闲块，并返回该块的用户空间地址。
        4. 调用 rt_mp_free()函数。将该块内存加入空闲块链表，进行内存的释放。
        ** 静态内存删除函数：   rt_mp_delete()
        ** 静态内存初始化函数： rt_mp_init()
        ** 静态内存申请函数：   rt_mp_alloc()
        ** 静态内存释放函数：   rt_mp_free()
    动态内存管理的函数：
    动态内存的典型场景开发流程：
        1. 初始化系统堆内存空间：rt_system_heap_init()。
        2. 申请任意大小的动态内存：rt_malloc()。
        3. 释放动态内存 rt_free()。回收系统内存，供下一次使用。
        ** 系统堆内存初始化：   rt_system_heap_init()
        ** 系统堆内存申请函数： rt_malloc()
        ** 系统堆内存释放函数： rt_free()
</code></pre>

      <div class="tags">
          <a href="/tags/RT-thread/" rel="tag"><i class="ic i-tag"></i> RT-thread</a>
      </div>
  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">Edited on</span>
    <time title="Modified: 2021-07-25 21:46:28" itemprop="dateModified" datetime="2021-07-25T21:46:28+08:00">2021-07-25</time>
  </span>
</div>

      
<div class="reward">
  <button><i class="ic i-heartbeat"></i> Donate</button>
  <p>Give me a cup of [coffee]~(￣▽￣)~*</p>
  <div id="qr">
      
      <div>
        <img data-src="/images/wechatpay.png" alt="~元~ WeChat Pay">
        <p>WeChat Pay</p>
      </div>
      
      <div>
        <img data-src="/images/alipay.png" alt="~元~ Alipay">
        <p>Alipay</p>
      </div>
      
      <div>
        <img data-src="/images/paypal.png" alt="~元~ PayPal">
        <p>PayPal</p>
      </div>
  </div>
</div>

      

<div id="copyright">
<ul>
  <li class="author">
    <strong>Post author:  </strong>~元~ <i class="ic i-at"><em>@</em></i>天元の
  </li>
  <li class="link">
    <strong>Post link: </strong>
    <a href="https://github.com/yuanyiyuan/yuanyiyuan.github.io.git/RT-thread__2/" title="RT-thread__2">https://github.com/yuanyiyuan/yuanyiyuan.github.io.git/RT-thread__2/</a>
  </li>
  <li class="license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.
  </li>
</ul>
</div>

  </footer>

</article>

  </div>
  

<div class="post-nav">
    <div class="item left">
      

  <a href="/RT-thread__1/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva4.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclxfdlttj20zk0m8npd.jpg" title="RT-thread__1">
  <span class="type">Previous Post</span>
  <span class="category"><i class="ic i-flag"></i> </span>
  <h3>RT-thread__1</h3>
  </a>

    </div>
    <div class="item right">
      

  <a href="/OpenMv%E7%AC%94%E8%AE%B0/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva4.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipet4bz0yj20zk0m8e81.jpg" title="OpenMv笔记">
  <span class="type">Next Post</span>
  <span class="category"><i class="ic i-flag"></i> </span>
  <h3>OpenMv笔记</h3>
  </a>

    </div>
</div>

  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="Contents">
          <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">1.创建线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%87%8D%E6%98%A0%E5%B0%84%E4%B8%B2%E5%8F%A3%E5%88%B0rt-Kprintf%E5%87%BD%E6%95%B0"><span class="toc-number">2.</span> <span class="toc-text">2.重映射串口到rt_Kprintf函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">3.线程管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">4.</span> <span class="toc-text">4.消息队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">5.</span> <span class="toc-text">5.信号量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E4%BA%92%E6%96%A5%E9%87%8F"><span class="toc-number">6.</span> <span class="toc-text">6.互斥量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E4%BA%8B%E4%BB%B6"><span class="toc-number">7.</span> <span class="toc-text">7.事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E8%BD%AF%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8%EF%BC%9A"><span class="toc-number">8.</span> <span class="toc-text">8.软件定时器：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E9%82%AE%E7%AE%B1"><span class="toc-number">9.</span> <span class="toc-text">9.邮箱</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E4%B8%AD%E6%96%AD%E7%AE%A1%E7%90%86"><span class="toc-number">10.</span> <span class="toc-text">10.中断管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">11.</span> <span class="toc-text">11.双向链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">12.</span> <span class="toc-text">12.内存管理</span></a></li></ol>
      </div>
      <div class="related panel pjax" data-title="Related">
      </div>
      <div class="overview panel" data-title="Overview">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="~元~"
      data-src="/images/avatar.jpg">
  <p class="name" itemprop="name">~元~</p>
  <div class="description" itemprop="description"></div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/archives/">
        <span class="count">11</span>
        <span class="name">posts</span>
      </a>
    </div>
    <div class="item tags">
      <a href="/tags/">
        <span class="count">5</span>
        <span class="name">tags</span>
      </a>
    </div>
</nav>

<div class="social">
      <a href="https://github.com/yuanyiyuan" title="https:&#x2F;&#x2F;github.com&#x2F;yuanyiyuan" class="item github"><i class="ic i-github"></i></a>
      <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;twitter.com&#x2F;yourname"><i class="ic i-twitter"></i></span>
      <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;yourname"><i class="ic i-zhihu"></i></span>
      <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTE5ODc4NTU1NDQ=" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;1987855544"><i class="ic i-cloud-music"></i></span>
      <span class="exturl item weibo" data-url="aHR0cHM6Ly93ZWliby5jb20veW91cm5hbWU=" title="https:&#x2F;&#x2F;weibo.com&#x2F;yourname"><i class="ic i-weibo"></i></span>
      <span class="exturl item about" data-url="aHR0cHM6Ly9hYm91dC5tZS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;about.me&#x2F;yourname"><i class="ic i-address-card"></i></span>
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/" rel="section"><i class="ic i-home"></i>Home</a>
  </li>

    
  <li class="item">
    <a href="/about/" rel="section"><i class="ic i-user"></i>About</a>
  </li>

        
  <li class="item dropdown">
      <a href="javascript:void(0);"><i class="ic i-feather"></i>Posts</a>
    <ul class="submenu">

        
  <li class="item">
    <a href="/archives/" rel="section"><i class="ic i-list-alt"></i>Archives</a>
  </li>

        
  <li class="item">
    <a href="/categories/" rel="section"><i class="ic i-th"></i>Categories</a>
  </li>

        
  <li class="item">
    <a href="/tags/" rel="section"><i class="ic i-tags"></i>Tags</a>
  </li>

  </ul>
    
  <li class="item">
    <a href="/friends/" rel="section"><i class="ic i-heart"></i>friends</a>
  </li>

    
  <li class="item">
    <a href="/links/" rel="section"><i class="ic i-magic"></i>links</a>
  </li>


</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
        <a href="/RT-thread__1/" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a>
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
        <a href="/OpenMv%E7%AC%94%E8%AE%B0/" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a>
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          
<div class="rpost pjax">
  <h2>Random Posts</h2>
  <ul>
      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/hello-world/" title="Hello World">Hello World</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/C%E8%AF%AD%E8%A8%80%E4%B9%8B%E8%BF%9B%E9%98%B6/" title="C语言之进阶">C语言之进阶</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/Vscode%20quick/" title="VScode 快捷键">VScode 快捷键</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/C%E8%AF%AD%E8%A8%80/" title="C语言">C语言</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/HAL/" title="HAL">HAL</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/arduino%E7%AC%94%E8%AE%B0/" title="arduino常见的库及其使用">arduino常见的库及其使用</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/OpenMv%E7%AC%94%E8%AE%B0/" title="OpenMv笔记">OpenMv笔记</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/LINUX%E7%AF%87/" title="LINUX篇">LINUX篇</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/RT-thread__1/" title="RT-thread__1">RT-thread__1</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/RT-thread__2/" title="RT-thread__2">RT-thread__2</a></span>
  </li>

  </ul>
</div>
<div>
  <h2>Recent Comments</h2>
  <ul class="leancloud-recent-comment"></ul>
</div>

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 2020 – 
    <span itemprop="copyrightYear">2021</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">~元~ @ Tian yuan</span>
  </div>
  <div class="powered-by">
    Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<a href="https://github.com/amehime/hexo-theme-shoka">Shoka</a>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: 'RT-thread__2/',
    favicon: {
      show: "（●´3｀●）Goooood",
      hide: "(´Д｀)Booooom"
    },
    search : {
      placeholder: "Search for Posts",
      empty: "We didn't find any results for the search: ${query}",
      stats: "${hits} results found in ${time} ms"
    },
    valine: true,fancybox: true,copyright: 'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="/js/app.js?v=0.2.5"></script>




</body>
</html>
