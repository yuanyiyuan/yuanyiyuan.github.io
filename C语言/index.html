



<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="天元の" href="https://github.com/yuanyiyuan/yuanyiyuan.github.io.git/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="天元の" href="https://github.com/yuanyiyuan/yuanyiyuan.github.io.git/atom.xml" />
<link rel="alternate" type="application/json" title="天元の" href="https://github.com/yuanyiyuan/yuanyiyuan.github.io.git/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/css/app.css?v=0.2.5">

  
  <meta name="keywords" content="C语言" />


<link rel="canonical" href="https://github.com/yuanyiyuan/yuanyiyuan.github.io.git/C%E8%AF%AD%E8%A8%80/">



  <title>
C语言 |
Tian yuan = 天元の = 宇宙中的每一粒尘埃都有着迷人的故事</title>
<meta name="generator" content="Hexo 5.4.0"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">C语言
  </h1>
  
<div class="meta">
  <span class="item" title="Created: 2021-07-05 11:25:13">
    <span class="icon">
      <i class="ic i-calendar"></i>
    </span>
    <span class="text">Posted on</span>
    <time itemprop="dateCreated datePublished" datetime="2021-07-05T11:25:13+08:00">2021-07-05</time>
  </span>
</div>


          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="Toggle navigation bar">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/" rel="start">Tian yuan</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
        <ul>
          <li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gicm0fdw5cj20zk0m8hdt.jpg"></li>
          <li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gicit4jrvuj20zk0m8785.jpg"></li>
          <li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipevgoki5j20zk0m84qp.jpg"></li>
          <li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giclxxcb6rj20zk0m8b29.jpg"></li>
          <li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipexe4oykj20zk0m87ji.jpg"></li>
          <li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gicis081o9j20zk0m8dmr.jpg"></li>
        </ul>
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="article wrap">
    
<div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList">
<i class="ic i-home"></i>
<span><a href="/">Home</a></span>
</div>

    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="en">
  <link itemprop="mainEntityOfPage" href="https://github.com/yuanyiyuan/yuanyiyuan.github.io.git/C%E8%AF%AD%E8%A8%80/">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/images/avatar.jpg">
    <meta itemprop="name" content="~元~">
    <meta itemprop="description" content="宇宙中的每一粒尘埃都有着迷人的故事, ">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="天元の">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <p>！！！———————–C语言—————————-！！！</p>
<p>基础知识：<br>    计算机定义： 仅仅是一个统称，包括台式机，笔记本，服务器，手机，无人机等<br>    计算机的组成： 硬件 和 软件<br>         硬件部分： 必须的三大硬件：<br>    内存 &lt;暂存CPU运算前的数据和运算之后的数据 （数据操作【读/写】速度快，重启或关机后数据丢失）&gt;<br>    CPU &lt;功能：数据运算、控制外设（CPU运算的数据来自外设，经过CPU运算后再回归外设—&gt; 从外设读取数据，向外设写入数据）CPU内也可暂存数据，存储容量极其小，数据操作速度最快&gt;<br>    硬盘&lt;永久性存储数据 （计算机重启/关机数据不会丢失，数据操作速度很慢）&gt;<br>    ———————————————————————<br>       数据操作比较： CPU &gt; 内存 &gt; 硬盘<br>       容量比较：        硬盘 &gt; 内存 &gt; CPU<br>    ———————————————————————<br>    外设：除了CPU其他任何硬件都是外设(给CPU提供数据  或  将运算完的数据保存起来 )</p>
<pre><code>    软件部分：  分三类
</code></pre>
<p>*** 操作系统  &lt;操作硬件（通过操作系统的驱动程序来完成），给程序分配CPU资源和内存资源&gt;<br>    shell终端程序&lt;接收用户输入的命令然后执行命令&gt;—&gt;（类似于二管家）<br>**  各种应用程序&lt;完成用户不同的功能   eg: QQ  、抖音 等&gt;</p>
<p>主流的操作系统：<br>windows<br>linux （重点）<br>   /—&gt;:   Ubuntu(乌班图),  Fedore,  Kali(黑客)<br>苹果：macOS   iOS<br>安卓：本质就是Linux<br>webOS(未来趋势)</p>
<p>linux系统理念（信仰）：一切皆文件<br>        在Linux系统中，软件要访问硬件必须找到这个硬件对应的文件，通过访问文件来间接访问硬件外设<br>无论何种操作系统，文件的管理必须依赖某种文件系统：硬盘上的文件系统为NTFS  ； U盘上的文件系统为FAT32  ；<br>        <em><strong>不同的文件系统管理文件的方式方法是不一样的</strong></em></p>
<hr>
<pre><code>                     C语言编程基础
            //*****程序最终玩的是内存*****//
</code></pre>
<p>字节Byte：计算机中将内存分成一格一格，每一格用来存一个数字，每一格即为一字节，内存的最小存储单元为字节<br>地址address：计算机中给内存的每个字节指定一个编号，此编号从  0  开始，此编号即为 地址<br>存储区 buffer：计算机中将一个字节或者多个字节形成的存储单元  称为 存储区<br>首地址/起始地址base address ：存储区中第一个字节的地址 </p>
<p>一. 基础___1</p>
<p>Half : 一半<br>Byte : 字节 ，1字节<br>Word : 字 ，4字节<br>HalfWord : 半字 ， 2字节<br>DoubleWord :  双字 ，8字节</p>
<p>占位符 ：<br>    数据类型        占位符   [%d –&gt; 4字节]<br>    char         %c , %hhd        [ 4/2/2 = 1 Byte]<br>    unsigned char    %c , %hhd<br>    short        %hd<br>    usnigned short    %hu<br>    int        %d<br>    unsigned int    %u<br>    long        %ld<br>    unisgned long    %lu<br>    float        %f  , %g       //  前者保留多余的0 ，后者不会保留<br>    double        %lf , %lg</p>
<p>   — 数据回滚 ： eg : char : -128~127  若超过127 ，则从 -128 开始 往上加</p>
<p>转义字符：<br>    ‘ \n ‘ : 让光标移动到下一行首<br>    ‘ \r ‘ : 让光标移动到当前行首<br>    ‘ \t ‘ ：TAB键<br>    ‘ \ ‘ : 得到一个<br>    ‘ &#39; ‘  : 得到一个  ‘<br>    ‘ &quot; ‘  : 得到一个  “<br>    ‘ %% ‘  ：得到一个  %<br>进制转换： 计算机中数字都是在内存中,并且数字都是以二进制的形式存储，计算机对数字的表示形式有：2进制、4进制、8进制、16进制<br>         &lt;不管是哪种形式，在内存的中的数字不会随着进制的不同而改变&gt;  8,10,16进制给程序员看,方便。  2进制给计算机看,计算机只认2进制</p>
<pre><code>  计算机中把内存中每个字节又分8段,每段只能记录0和1，要想把一个数字存储到内存中,必须将这个数字分拆成若干个0和1，每段对应的专业术语：位,bit,bit位
    1Byte = 8bit   2Byte = 16bit ......
</code></pre>
<p>*** 二进制的特点：<br>    二进制的编号：是从0开始<br>    eg:  高位           低位<br>          7 6 5 4 3 2 1 0     二进制的编号<br>          0 1 0 0 0 0 0 0     二进制数<br>    二进制数中每个1代表一个10进制数字，这个数字是2的编号次方   128   64   32   16   8   4   2   1 </p>
<p>负数的十进制和二进制不能直接转换,必须借助相反数 ： 首先计算相反数 ； 然后将相反数转成二进制 ； 最后取反加1</p>
<p><em><strong>原码，反码，补码</strong></em><br>原码： 原本的二进制数<br>反码： 将原码进行取反   （ 0变1 ， 1变0 ）<br>补码： 将对应的反码加1<br>—– 计算机中运行是以补码的方式运行，以原码的方式显示—–</p>
<p>二. 基础___2</p>
<p>运算符：<br>    算数运算符 ： +  -  *  /  % （取余）<br>        %不能对浮点数使用<br>        %的结果与其左边的数字符号一致   eg :  -7%2= -1    7%-2 =1<br>        /  如果除数为浮点数，最后得到  inf  无穷大   eg :  5/0.0</p>
<pre><code>赋值运算符 ： =  就是将变量对应的内存数字进行改变 （将右边的值赋值给左边的变量）

复合运算符 : 赋值运算符和其他运算符结合起来使用  eg :   a += b;  //等价于a = a + b;     a %=b; //等价于a = a%b;  ......

自增运算符(++)和自减运算符(--) ：    自增运算符就是让变量对应的内存数值加1  ； 自减运算符就是让变量对应的内存数值减1   eg : a++; //等价于a = a+1; 
        两种情况： b=a++; / b=a--;  :  先赋值 再 加减      b=++a; / b=--a; : 先加减 再 赋值
        不能给常量进行 自增、自减  和 给常量(不可改变的数字)、表达式赋值

关系运算符 ： ==  、 &gt;=    、 &lt;=  、  !=    、  &gt;   、 &lt;
逻辑运算符 ： &amp;&amp;     ||      ！
    ***（短路运算）  
    eg:
         A &amp;&amp; B:  如果A的值为假,则B不处理,B的代码不执行
         A || B:  如果A的值为真,则B不处理,B的代码不执行
        运算结果：1(真)和0(假)
</code></pre>
<p>*** 位(bit)运算符 :  位运算就是对内存中二进制数进行运算，并且C语言专门提供对应的运算符<br>        位与：&amp;(清0)     —&gt;   任何数跟0做位与,结果为0,任何数跟1做位与,保持原值<br>        位或 : |(置1)    —&gt;   任何数跟1做位或,结果为1,任何数跟0做位或,保持原值<br>        位异或: ^(反转)  —&gt;   0变1,1变0<br>        位反: <del>(取反)</del>    —&gt;   相同为0,不同为1,应用于取反场合<br>    移位运算符  :  就是将二进制数统一向左或者向右移动n个位置(简称左移,右移)<br>        移位运算符特点：<br>       1.向左移动后右边空出来的数据用0来填充<br>          例如：A数据前提是char类型<br>          A=0x5A = 01011010<br>          A &lt;&lt; 2  =  01011010  &lt;&lt; 2 结果为： 01101000 = 0x68<br>       2. 无符号类型数字右移时左边空出来的数据用0来填充<br>          例如：01011010 &gt;&gt; 2 结果为：00010110 = 0x16<br>       3.有符号类型数字右移时左边空出来的数据用符号位填充<br>          例如:10100101(前提是char类型) &gt;&gt; 2 结果为： 11101001  = 0xE9<br>        4.左移n位相当于乘以2的n次方<br>        5.右移n位相当于除以2的n次方<br>    **  如果程序中将来涉及乘或者除2的n次方运算,务必用左移或者右移(高薪) [严重鄙视用*或者/,因为后者的执行效率相当低下！]<br>    **  不管是位运算符(&amp;,|,^,<del>)</del>还是左移,右移他们都不会改变变量本身的值！<br>        eg :    int a = 3;<br>                int b = a &lt;&lt; 1;<br>                printf(“a = %d, b = %d\n”, a, b);     //a = 3, b = 6</p>
<hr>
<p>  ***   切记实际开发常用的位操作公式：<br>        清0公式：<br>        1.将某个变量的某1个位清0,其他位保持不变<br>            A &amp;= ~(1 &lt;&lt; 位编号); //类似：A = A &amp; ~(1 &lt;&lt; 位编号)<br>        2.将某个变量的某2个连续的位清0,其他位保持不变<br>            A &amp;= ~(3 &lt;&lt; 位编号);<br>        3.将某个变量的某3个连续的位清0,其他位保持不变<br>            A &amp;= ~(7 &lt;&lt; 位编号);<br>        4.将某个变量的某4个连续的位清0,其他位保持不变<br>            A &amp;= ~(0xF &lt;&lt; 位编号);</p>
<pre><code>    置1公式：
    1.将某个变量的某1个位置1,其他位保持不变
        A |= (1 &lt;&lt; 位编号);
    2.将某个变量的某2个连续的位置1,其他位保持不变
        A |= (3 &lt;&lt; 位编号);
    3.将某个变量的某3个连续的位置1,其他位保持不变
        A |= (7 &lt;&lt; 位编号);
    4.将某个变量的某4个连续的位置1,其他位保持不变
        A |= (0xF &lt;&lt; 位编号);
</code></pre>
<hr>
<p>  <strong><em>\  取地址运算符&amp;和解引用运算符</em>  /</strong>*<br>    —————————————-<br>    地址特性：计算机中地址由32位二进制数组成,也就是一个地址32位,4字节<br>    取地址运算符&amp;作用：获取一个变量在内存对应的首地址, 占位符%p用来显示地址信息<br>    取地址运算符&amp;使用语法格式：  &amp;变量名;<br>    —————————————-<br>    解引用运算符<em>作用： 根据变量的首地址来 读/写 内存中的数据<br>    解引用运算符</em>使用语法格式：  *地址 ;  [可以直接操作内存了]  </p>
<pre><code>    eg:    scanf 函数功能 ：从键盘上接收到输入的数字并且保存到变量中
           scanf 函数语法 ： scanf ( &quot;输入格式&quot; , 地址列表 )
           scanf(&quot;%d&quot; , &amp;a );    // &amp;为取地址符

条件运算符(又称三目运算符) :
    语法格式：整个表达式结果D = 条件表达式A ? 表达示B : 表达式C
    语义：如果A为真,D=表达式B的运算结果,否则D=表达式C的运算结果
</code></pre>
<p>三. 基础___3<br>    数据类型的转换 ：<br>    数据类型的转换分两种 ： 隐式转换和强制转换<br>        隐式转换特点：如果表达式中不同数字的数据类型不同,编译器先将不同的数据类型转换成相同的数据类型之后再做运算<br>                隐式转换分三种情况：<br>                a)隐式转换过程中必须把占内存小的类型转换成占内容大的类型<br>                b)如果既有整型数据类型还有浮点数据类型,编译器自动将整型数据类型转换成浮点类型<br>                c)如果既有无符号数据类型还有有符号数据类型,编译器自动将有符号转无符号数据类型<br>        —隐式转换的致命缺陷代码的可读性很差！<br>        强制转换(建议使用的转换, 目的：提高代码的可读性)<br>                a)强制转换语法格式：目标类型变量 = (目标类型)源类型变量；<br>                b)注意：强制数据类型转换可能会造成数据的丢失<br>***  不管哪种类型转换都不会修改变量本身的值 ***<br>        eg：<br>            int a = 555;<br>            char b = (char)a;<br>            printf(“b = %d, a = %d\n”); //  b = 43   a = 555    —&gt;   b=555-128-128-128-128=43</p>
<pre><code>C程序的流程控制 ： C程序是一个结构化程序,就是以顺序,分支,循环三种基本结构构建的单入口单出口的程序
     顺序结构：就是CPU从上到下依次运行
     分支结构：实现多选一
            分支结构分两类：条件分支和开关分支
            --------------------------------
            条件分支：if(表达式1) &#123;
                        语句1;
                        &#125;   
                        else if(表达式2) &#123;
                        语句2;
                        &#125;
                        ...
                        else if(表达式N) &#123;
                        语句N;
                        &#125;
                        语义：如果表达式1为真,那么执行语句1,如果表达式1不为真,那么执行表达式2,如果表达式2为真,那么执行语句2,如果表达式2不为真,依次向下判断
                条件分支为用 if 的这一类 ， if  、 if \else  、 if \else if \..\else 
            --------------------------------
            开关分支: switch(控制表达式) &#123;
                            case 常量表达式1:
                        语句1;
                        break;
                            case 常量表达式2:
                        语句2;
                        break;
                            ...
                            case 常量表达式N:
                        语句N;
                        break;
                            default:
                        语句M;
                        break;
                        &#125;     
                    执行过程：控制表达式的值和下面case对应的常量表达式的值一样(相等), 那么就会执行对应的语句,一旦遇到break,switch...case开关分支立刻结束,
                             如果case都不相等,最后只能执行default对应的语句
              ***控制表达式被当成一个整数处理(int),可以是字符,但是不能是浮点数和字符串(例如：&quot;abc&quot;)
              ***常量表达式必须是常量, 不允许有重复的分支case
              ***default关键字可以写在任意case的前面,但是需要添加break， 如果default关键字写在最后,break是可以省略的
                ------------------------------------------------------------------------------
                *****如果其中某个case对应的break没有添加,当这个case成立时,并且运行其语句之后会继续执行下一个case  [时刻注意 break ]
                *****分支case或者default中如果定义变量,记得加&#123;&#125; ， 将来这个变量只能给对应的case使用！ [局部变量]
                ------------------------------------------------------------------------------
            --------------------------------
            总结：if...else和switch..case对比：
            1.switch...case能做的,if...else都能做
            2.if...else能做的,switch...case不一定能做,比如处理浮点数或者字符串
            3.switch...case某些场合极其繁琐
                eg：判断0~1000的范围,如果用switch...case,必须添加1000条case , 但是如果用if语句,一条拿下：if(xxx &gt; 0 &amp;&amp; xxx &lt; 1000)
            4.编译器对switch...case生成的代码量要比if...else要少,所以switch代码执行效率高
    循环结构: 将一组语句重复多次执行
            三种类型循环：for循环,while循环,do...while循环
            ---------------------------------------------
            for循环:     for(表达式1; 表达式2; 表达式3) &#123;
                            循环语句;
                        &#125;
                        1：首先计算,运行表达式1(只做一次)
                        2：然后计算,运行表达式2
                            如果表达式2的结果为真,那么就执行运行循环语句
                            如果表达式2的结果为假,那么for循环结束退出
                        3：如果表达式2的结果为真,那么就执行运行循环语句,并且当循环语句执行完毕,再接着计算,运行表达式3,表达式3运行完毕,重复第二步骤
            ---------------------------------------------
            while循环:   while(循环控制表达式) &#123;
                        循环语句;
                        &#125;
                        1：首先计算,运算循环控制表达式
                            如果计算的结果为真,那么执行循环语句
                            如果计算的结果为假,while循环直接结束
                        2：当循环语句执行完毕,继续执行运行第一步骤
            ---------------------------------------------
            do...while循环:  do &#123;
                                循环语句;
                            &#125;while(循环控制表达式); 
                        1：先执行循环语句;  //第一次没有做判断
                        2：然后计算,运行循环表达式
                            如果为真,继续执行循环语句,后续依次重复
                            如果为假,循环结束
                        &lt;特点：do-while至少执行一次！&gt;
            ---------------------------------------------
    break : 终止循环(for/while/do-while), 嵌套是接收内层
    continue: 终止本次循环,继续下一次循环
    goto语句: 可以让CPU跳转到任何一条语句去执行
        goto 标签名;   // &lt;标签名根据标识符命名规则来定&gt;
</code></pre>
<p>四. 基础___4<br>    计算机程序最终玩内存,玩内存首先得分配,目前分配内存的方法只有一种：定义变量   —&gt; 但此分配代码及其繁琐<br>    数组： 是一种分配内存的方法,分配的内存能够存储多个类型相同的数据<br>        优点：能够大量分配内存<br>        缺点：数据类型必须相同，不能做到随时用随时分配<br>    数组分配内存的语法格式：（为 定义数组）<br>        元素数据类型  数组名[长度(又称数组元素个数)] = {初始化列表(如果有多个,用逗号,分开)};<br>        eg:  int   a[5] = {1,2,3,4,5};   //定义了一个数据类型为int 的数组，有5个元素的存储空间，5<em>4Byte = 20 Byte , 分配了连续的20字节的内存空间，每个元素占4Byte<br>    特点：   1.数组分配的内存是连续的<br>            2.数组名就是整个数组的首地址,等于数组第0个元素的首地址<br>            3.数组的长度又称数组元素的个数,而不是整个数组分配内存的大小<br>            4.数组下标就是数组中元素的编号，下标从0开始<br>            5.数组中元素的访问是通过运算符”[]”和下标来进行访问<br>    &lt;数组名 即为 一个指针， 指向首地址(即第0个元素)，下标为指针的偏移量，因为是连续的内存空间，通过偏移量，指针偏移即可指向对应内存空间的值&gt;<br>    二维数组：由多个一维数组组成的数组, 二维数组的每个元素是一个数组， 二维数组的本质还是一维数组,只是形式上将一维数组再次分组而已<br>        数组元素类型  二维数组名 [二维数组长度] [一维数组长度] = {初始化表};<br>        eg:  int a[5][10];<br>                    //a 为 一个包含5个元素的数组， 每个元素又包含10个元素的数组 ，且每个元素的数据类型为int ，5</em>10*4Byte = 200 Byte<br>                    //a[0]代表a的第0个元素,而第0个元素又是一个一维数组 [a[0]是一维数组的首地址]<br>                    //a[0][0]代表a的第0个一维数组元素的第0个元素, (a[0][0]就是二维数组中的某个元素)<br>            &lt; a[i][j]代表a的第i个一维数组元素的第j个元素 , [ 二维数组长度可以省略,但是一维数组的长度不可省略 ] &gt;<br>    sizeof() 函数为计算数据类型所占的空间大小<br>            eg:   int a[2][3] = {0};<br>            a是二维数组的首地址=&amp;a[0][0]<br>            sizeof(a)：获取整个二维数组占用的内存大小<br>            sizeof(a[0]):获取二维数组中第0个一维数组元素占用的内存大小<br>            sizeof(a[0][0]):获取二维数组中第0个一维数组中第0个元素占用的内存大小<br>            sizeof(a)/sizeof(a[0]):获取二维数组的长度<br>            sizeof(a[0])/sizeof(a[0][0]):获取一维数组的长度</p>
<pre><code>目前C程序分配内存的方法两种：定义变量和定义数组   //由于数组的数据类型都是相同的，不方便
结构体： 能够包含大量的变量并且对变量的数据类型无要求
     结构体也是一种数据类型,是程序员自行定义的一种数据类型，结构体分配的内存也是连续的,一个成员挨着一个成员
    语法：
        方法一：
            struct  &#123;
              结构体成员; //又称结构体字段
            &#125;结构体变量名;
        ----------------------每次定义一个结构体变量,结构体成员都要重新写一遍
        方法二：
        --(声明结构体数据类型)
            struct  结构体名 &#123;
              结构体成员;
            &#125;;   //不会分配内存 ，构建结构体变量是才分配空间
        --(用结构体数据类型定义结构体变量)
            struct 结构体名  结构体变量名;
        ----------------------每次定义结构体变量,struct 结构体名每次都要书写
        方法三： 用typedef关键字给一个声明的结构体数据类型取别名，然后用别名定义结构体变量
                 typedef  原数据类型   别名;
        -(用typedef对声明的结构体取别名)
            1.  typedef struct &#123;
                    结构体成员;
                &#125;别名_t； 

            2.  typedef struct 结构体名&#123;
                    结构体成员;
                &#125;别名_t；    

            3.  typedef struct 结构体名 别名;  
        -(定义结构体变量)
            别名  结构体变量名;
        ------------------------------
结构体变量的初始化方式：
    struct 结构体名/别名  结构体变量名 = &#123;初始化的值&#125;;      //定义初始化的时候需要按照顺序全部初始化
    struct 结构体名/别名  结构体变量名 = &#123;
                .某个成员名 = 初始化值,
                .某个成员名 = 初始化值,
                ...
            &#125;;                                           //不用按照顺序,不用全部成员初始化

结构体变量成员的访问： 
    结构体变量名.成员名;                                  //将来可以访问这个成员的内存区域
    结构体指针变量名-&gt;成员名;                             //将来可以访问这个成员的内存区域

&lt;结构体变量之间可以直接赋值&gt;
&lt;结构体嵌套：结构体成员还是一个结构体&gt;

///-----------结构体内存对齐-----------\\\
结构体成员编译时默认按4字节对齐  (未占满4字节的也的跳过，以4字节的形式对齐)

联合体(共用体)： 联合体中所有成员是共用一块内存,优点节省内存
    联合体占用的内存按成员中占内存最大的来算

    大端模式/小端模式：
    小端模式：数据的低位在内存的低地址,数据的高位在内存的高地址处
    大端模式：数据的低位在内存的高地址,数据的高位在内存的低地址处

枚举：就是一堆整数的集合,列表,就是给整数取了个别名,提高代码的可读性
      枚举值默认是从0开始,后面的成员依次加1
    enum 枚举数据类型名 &#123;枚举值&#125;;
</code></pre>
<p>五. 基础___5<br>    任何C程序,C源文件都包含两部分内容：一对的变量(包括数组)和一堆的函数<br>    函数：函数就是一堆语句的组合,用以实现一些相对独立并且具有一定通用性的功能<br>    函数特点：<br>        1.由一条或者多条语句组成<br>        2.可以重复使用<br>    (函数声明)：告诉编译器,将来这个函数可以给别人或者自己使用， 函数声明是不分配内存空间的<br>            extern 返回值数据类型  函数名(形参表);    //函数声明加extern(提高代码的可读性)<br>                //函数定义在函数调用之前，可以省略函数声明,否则必须声明<br>    (函数定义)：就是一个函数的具体实现过程, 里面会包含一堆的语句将来可以给别人或者自己使用函数， 定义会分配内存<br>            返回值数据类型  函数名(形参表)<br>            {<br>            一堆的函数体语句;<br>            }<br>            函数定义特点：<br>                    返回值数据类型：就是函数运行完毕要给使用这个函数的代码返回一个数字， 那么这个数字必然有对应的数据类型<br>                    形参表：就是一堆的变量定义,这些变量只能在这个函数体内部使用,出了函数就不能用， 形参的值由使用这些函数的代码来赋值,形参的变量有多个,用逗号,分开<br>                    函数的返回值：如果函数需要返回一个数字,用关键字return, 例如：return 返回值<br>                    &lt;&lt;返回值的数字的类型和函数定义时的返回值数据类型要一致,否则会数据类型转换，造成数据的丢失&gt;&gt;<br>    (函数调用)：使用函数,调用函数,访问函数<br>            接收函数返回值的变量 = 函数名(实参表);<br>            // 实参表：就是给函数的形参表赋的值<br>            // 实参的内存空间和形参的内存空间是独立的,地址是不一样的,但是里面存储的数据是一样的！<br>            <strong>[这里的实参传形参为数据的拷贝，内存空间独立,修改形参的值不会修改对应实参的值]</strong><br>            <strong>[若传参的为数组/结构体/指针时，则传参为传入实参的首地址，修改形参则会修改对应实参的值]</strong><br>    return关键字：实现函数返回<br>    exit函数：让程序强制结束    // 使用此函数需要添加头文件：#include &lt;stdlib.h&gt;</p>
<pre><code>变量的作用域和可见性：
    C语言变量按照作用域和可见性分两类：局部非静态变量/局部静态变量/全局非静态变量/全局静态变量
    局部非静态变量：定义在函数内部的变量  
        使用范围： 从定义的地方开始依次向下直到最近的花括号结束
        变量生命周期： 从定义的地方操作系统就会给变量分配内存， 直到最近的花括号操作系统立马收回变量的内存， 下次使用再给变量重新分配内存
    全局非静态变量：定义在函数之外的变量    (慎用--&gt;极易出现乱序访问效果)
        使用范围：分两种情况 
                1.如果是本文件访问,范围是从定义的地方开始依次向下所有的函数都可以访问, 前面的函数无法访问
                2.如果是不同文件(跨文件)之间访问,范围是从声明的地方开始依次向下所有的函数都可以访问, 前面的函数无法访问
        变量生命周期： 从启动运行程序时操作系统就会为其分配内存， 直到程序结束,操作系统将其内存回收
    局部静态变量： (少用此类变量)
        使用范围：从定义的地方开始依次向下直到最近的花括号结束
        变量生命周期： 从定义的地方开始分配内存直到程序结束， 一次分配,程序不结束,下次不会分配,接着上一次的使用， 程序不结束,下次就不会重新分配内存
    全局静态变量：
        使用范围：只能用于定义变量的文件中,并且是从定义的地方开始依次向下， 所有的其他函数都可以访问,之前的函数不可访问 &lt;只能用于本文件,其他源文件不可访问&gt;
        变量生命周期：从启动运行程序时操作系统就会为其分配内存， 直到程序结束,操作系统将其内存回收
    ------静态(static) 扩大了局部变量的生命周期，限制了全局变量的使用范围------
    static修饰的变量和函数将来用起来相对比较安全,起到了间接保护的作用，乱序发生的概率降低了
</code></pre>
<p>六. 基础___6<br>    <em><strong>C语言的核心与灵魂</strong></em><br>    指针： 指针本质就是一个变量,而这个变量永远只能存储一个内存地址(编号)，此变量对应的专业术语叫指针变量<br>    <strong>指针变量</strong> ：    就是通过指针变量保存的地址就可以对这块内存区域任意访问(读查看,写修改)， 而指针指向的内存区域可以保存一个数字,而这个数字有数据类型的<br>    语法:    int  *  变量名;        //定义一个指针变量, 这个指针变量能够保存一块内存空间的首地址， 并且这块内存区域保存着一个int类型的数据<br>    *<strong>指针变量分配的内存空间为4字节或者8字节(因为是存放内存地址的，字节由计算机位数决定)，所以指针变量本身没有数据类型， 只是它指向的内存区域保存的数字有数据类型,所以int不是给指针变量用的，而是给指针变量指向的内存区域保存的数字用的</strong></p>
<pre><code>野指针：定义指针变量后若不初始化，此指针变量保存的一个地址值是随机的地址，此指针变量指向任意内存区域, 相当危险！！因为此块内存区域不是操作系统合法给你分配的内存！！
空指针：空指针变量保存一个空地址,用NULL表示,其实就是编号为0地址， 空指针不可以随意访问,否则造成程序的崩溃！
---------------------------------------------
如果定义一个指针变量,一开始不清楚它到底指向谁,千万不能不初始化,否则变成了野指针,所以此时要求初始化为空指针NULL,一旦初始化为NULL,将来程序后面使用时,
时时刻刻要记得对指针变量进行安全的判断,判断它是否为NULL,如果为NULL,让程序结束或者函数返回,如果为有效地址,程序才能继续通过指针变量进行操作
----------------------------------------------

指针变量初始化通过取地址&amp;  :  数据类型 *指针变量 = &amp;变量;    //取变量的地址 赋值给 指针变量
解引用运算符(取目标运算符)：  *指针变量 = 数值；            //通过指针变量找到其指向的内存空间的地址，并对其所对应的内存空间赋值

----------------------------------------------
指针运算(核心)
指针可以和一个整数做加减法运算,简称地址运算   [计算结果和指针指向的变量数据类型有关系  &lt; char型指针+1,表示实际地址+1 \short型指针+1,表示实际地址+2\...&gt;]
根据上面数组名即为指针的首地址的关系：  ---&gt;    &amp;a[2]是第2个元素的首地址 , a+2也是第2个元素的首地址

常量(const)：不可修改的值， 其值一经初始化再也不能改
常量指针：不能通过指针变量来修改指向的内存区域的值(保护内存区域不可乱改)    ---&gt; 指针所指的区域的地址，其对应的空间为常量[可指向任意区域，但那个区域不可更改]
    int const *p = &amp;a;   //定义初始化一个常量指针
指针常量：指针永远指向一块内存区域,不能再指向别的地方(保护指针不可乱指向)   ---&gt; 指针所指的区域的地址为常量[只能指向那个区域]
    int* const p = &amp;a;
常量指针常量：指针所指的区域的地址为常量，其对应的空间为常量 [只能指向那个区域，且那个区域也不能更改  (只能查看内存区域的值) ]
    const int * const p;
无数据类型指针：void *   : 它也是一个指针变量,也保存一个地址,同样占4字节内存空间， 只是它指向的内存区域的数据类型是不可知的
        --若要想通过无类型指针获取内存的数据， 必须做数据类型的转换(为了代码的可读性建议采用强制转换)   ---[实现了当想用对应数据类型的指针时，强转即可]

指针作为函数的形参： 函数通过指针能够访问操作指向的内存
指针作为函数的返回值： 函数的返回值是一个指针， 将来函数返回的是一个地址 [与返回的变量的内存生命周期相关,与变量的使用范围无关] 
        **&lt;千万要注意别返回一个野指针&gt;**
    语法:    返回值数据类型 *函数名(形参表)
             &#123;函数体语句&#125;
字符串和指针: 定义一个字符指针变量并且指向一个字符串,本质是指向这个字符串的首地址,也是第0个字符的首地址
        **&lt;不能通过字符指针变量来修改字符串的值,只能查看 [字符串存储在  常量存储区/静态数据区  ，所以不能修改] &gt;**

指针函数： 就是一个函数,只是它的返回值是一个指针   -----&gt;[即为上面提到的---&gt; 指针作为函数的返回值]
    函数名就是整个函数里面代码的首地址, 简称函数的首地址，也等于第一条语句所在内存的首地址

函数指针： 本质就是一种程序员自己定义的数据类型(跟int,结构体数据类型一样的)，它保存着一个函数的地址
    语法： 返回值数据类型 (*函数指针名) (形参表);      //不会分配内存  并且大型程序中写头文件
函数指针变量： 用来保存函数的地址
    定义语法：  函数指针名   函数指针变量;
        [---可通过函数指针变量来访问指向的函数,通过函数指针变量来调用指向的函数---]
        语法：     函数指针变量名(实参表);
回调函数： 一个函数可以被当成参数传递给别的函数,这个函数的参数必须是函数指针， 来保存回调函数的地址
----------------------------------------------------------------------------------------
多级指针： 指向一级指针的指针,也就是存放着一级指针变量的地址
    语法：  数据类型 **二级指针变量名 = 一级指针的地址;
    二级指针的意味着里面每个元素是一个指针,而指针又指向对应的内存
</code></pre>
<p>/——————————————————————————————<br>                    常用函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">动态分配内存： malloc 函数</span><br><span class="line">     void *malloc(unsigned long size);   //随时随地的连续分配内存 ， 且分配的内存,只要不调用free函数就不会释放</span><br><span class="line">                //size: 指定要分配的内存大小,单位是字节</span><br><span class="line">                //返回值： 返回分配的内存的首地址,注意要做强制类型转换， 如果分配内存失败,返回NULL</span><br><span class="line">释放动态分配的内存： free 函数</span><br><span class="line">     void free(void *p);              //调用此函数即可随时释放malloc分配的内存,将内存资源归还给操作系统</span><br><span class="line">                //p: 传递malloc分配的内存的首地址</span><br><span class="line">                //  p = NULL; //务必养成好习惯,否则p就成野指针了</span><br><span class="line">设置内存数据： memset 函数</span><br><span class="line">     void memset(void *p, int data, int len);</span><br><span class="line">                //p: 传递要设置的内存的首地址</span><br><span class="line">                //data: 传递要指定的数据</span><br><span class="line">                //len: 传递要设置的内存大小</span><br><span class="line"></span><br><span class="line">strlen函数：功能获取字符串有效长度(不包括&#x27;\0&#x27;)</span><br><span class="line">strcat函数：功能是字符串拼接</span><br><span class="line">strcmp函数：功能是字符比较函数</span><br><span class="line">strcpy函数: 字符串拷贝函数,会覆盖原先的字符串</span><br><span class="line">sprintf函数：功能把数字转成字符串保存到数组中</span><br></pre></td></tr></table></figure>
      <div class="tags">
          <a href="/tags/C%E8%AF%AD%E8%A8%80/" rel="tag"><i class="ic i-tag"></i> C语言</a>
      </div>
  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">Edited on</span>
    <time title="Modified: 2021-07-25 21:53:11" itemprop="dateModified" datetime="2021-07-25T21:53:11+08:00">2021-07-25</time>
  </span>
</div>

      
<div class="reward">
  <button><i class="ic i-heartbeat"></i> Donate</button>
  <p>Give me a cup of [coffee]~(￣▽￣)~*</p>
  <div id="qr">
      
      <div>
        <img data-src="/images/wechatpay.png" alt="~元~ WeChat Pay">
        <p>WeChat Pay</p>
      </div>
      
      <div>
        <img data-src="/images/alipay.png" alt="~元~ Alipay">
        <p>Alipay</p>
      </div>
      
      <div>
        <img data-src="/images/paypal.png" alt="~元~ PayPal">
        <p>PayPal</p>
      </div>
  </div>
</div>

      

<div id="copyright">
<ul>
  <li class="author">
    <strong>Post author:  </strong>~元~ <i class="ic i-at"><em>@</em></i>天元の
  </li>
  <li class="link">
    <strong>Post link: </strong>
    <a href="https://github.com/yuanyiyuan/yuanyiyuan.github.io.git/C%E8%AF%AD%E8%A8%80/" title="C语言">https://github.com/yuanyiyuan/yuanyiyuan.github.io.git/C语言/</a>
  </li>
  <li class="license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.
  </li>
</ul>
</div>

  </footer>

</article>

  </div>
  

<div class="post-nav">
    <div class="item left">
      

  <a href="/Vscode%20quick/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclfdu6exj20zk0m87hw.jpg" title="VScode 快捷键">
  <span class="type">Previous Post</span>
  <span class="category"><i class="ic i-flag"></i> </span>
  <h3>VScode 快捷键</h3>
  </a>

    </div>
    <div class="item right">
      

  <a href="/LINUX%E7%AF%87/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclhfehz7j20zk0m8u0x.jpg" title="LINUX篇">
  <span class="type">Next Post</span>
  <span class="category"><i class="ic i-flag"></i> </span>
  <h3>LINUX篇</h3>
  </a>

    </div>
</div>

  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="Contents">
      </div>
      <div class="related panel pjax" data-title="Related">
      </div>
      <div class="overview panel" data-title="Overview">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="~元~"
      data-src="/images/avatar.jpg">
  <p class="name" itemprop="name">~元~</p>
  <div class="description" itemprop="description"></div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/archives/">
        <span class="count">14</span>
        <span class="name">posts</span>
      </a>
    </div>
    <div class="item tags">
      <a href="/tags/">
        <span class="count">5</span>
        <span class="name">tags</span>
      </a>
    </div>
</nav>

<div class="social">
      <a href="https://github.com/yuanyiyuan" title="https:&#x2F;&#x2F;github.com&#x2F;yuanyiyuan" class="item github"><i class="ic i-github"></i></a>
      <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;twitter.com&#x2F;yourname"><i class="ic i-twitter"></i></span>
      <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;yourname"><i class="ic i-zhihu"></i></span>
      <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTE5ODc4NTU1NDQ=" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;1987855544"><i class="ic i-cloud-music"></i></span>
      <span class="exturl item weibo" data-url="aHR0cHM6Ly93ZWliby5jb20veW91cm5hbWU=" title="https:&#x2F;&#x2F;weibo.com&#x2F;yourname"><i class="ic i-weibo"></i></span>
      <span class="exturl item about" data-url="aHR0cHM6Ly9hYm91dC5tZS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;about.me&#x2F;yourname"><i class="ic i-address-card"></i></span>
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/" rel="section"><i class="ic i-home"></i>Home</a>
  </li>

    
  <li class="item">
    <a href="/about/" rel="section"><i class="ic i-user"></i>About</a>
  </li>

        
  <li class="item dropdown">
      <a href="javascript:void(0);"><i class="ic i-feather"></i>Posts</a>
    <ul class="submenu">

        
  <li class="item">
    <a href="/archives/" rel="section"><i class="ic i-list-alt"></i>Archives</a>
  </li>

        
  <li class="item">
    <a href="/categories/" rel="section"><i class="ic i-th"></i>Categories</a>
  </li>

        
  <li class="item">
    <a href="/tags/" rel="section"><i class="ic i-tags"></i>Tags</a>
  </li>

  </ul>
    
  <li class="item">
    <a href="/friends/" rel="section"><i class="ic i-heart"></i>friends</a>
  </li>

    
  <li class="item">
    <a href="/links/" rel="section"><i class="ic i-magic"></i>links</a>
  </li>


</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
        <a href="/Vscode%20quick/" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a>
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
        <a href="/LINUX%E7%AF%87/" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a>
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          
<div class="rpost pjax">
  <h2>Random Posts</h2>
  <ul>
      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/hello-world/" title="Hello World">Hello World</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/MSP432%E7%A7%BB%E6%A4%8DRT-Thread/" title="MSP432移植RT-Thread">MSP432移植RT-Thread</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/HAL/" title="HAL">HAL</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/STM32CubeMx%E7%A7%BB%E6%A4%8Dfinsh%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/" title="STM32CubeMx移植RT-Thread的RTOS和finsh步骤和解决办法">STM32CubeMx移植RT-Thread的RTOS和finsh步骤和解决办法</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/MSP432Diver/" title="MSP432_Diver">MSP432_Diver</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/Vscode%20quick/" title="VScode 快捷键">VScode 快捷键</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/LINUX%E7%AF%87/" title="LINUX篇">LINUX篇</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/RT-thread__1/" title="RT-thread__1">RT-thread__1</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/arduino%E7%AC%94%E8%AE%B0/" title="arduino常见的库及其使用">arduino常见的库及其使用</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/git%E7%9A%84%E4%BD%BF%E7%94%A8/" title="Git的使用">Git的使用</a></span>
  </li>

  </ul>
</div>
<div>
  <h2>Recent Comments</h2>
  <ul class="leancloud-recent-comment"></ul>
</div>

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 2020 – 
    <span itemprop="copyrightYear">2021</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">~元~ @ Tian yuan</span>
  </div>
  <div class="powered-by">
    Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<a href="https://github.com/amehime/hexo-theme-shoka">Shoka</a>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: 'C语言/',
    favicon: {
      show: "（●´3｀●）Goooood",
      hide: "(´Д｀)Booooom"
    },
    search : {
      placeholder: "Search for Posts",
      empty: "We didn't find any results for the search: ${query}",
      stats: "${hits} results found in ${time} ms"
    },
    valine: true,fancybox: true,copyright: 'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="/js/app.js?v=0.2.5"></script>




</body>
</html>
